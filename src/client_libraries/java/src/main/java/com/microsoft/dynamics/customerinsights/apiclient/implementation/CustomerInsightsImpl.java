/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.dynamics.customerinsights.apiclient.implementation;

import com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.dynamics.customerinsights.apiclient.models.AcceptedResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.ActivateSegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.ApiError;
import com.microsoft.dynamics.customerinsights.apiclient.models.ApiErrorResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.AttributeDataProfile;
import com.microsoft.dynamics.customerinsights.apiclient.models.CancelAWorkflowJobHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CopyAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateAMeasureHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateAnEntityHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateARelationshipHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateASegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreatedResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateWorkflowRefreshScheduleHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DataSourceInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeactivateSegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteADataSourceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteAMeasureHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteARelationshipHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeletesARoleAssignmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteSegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeletionResponse;
import com.microsoft.dynamics.customerinsights.apiclient.models.EntityDataProfile;
import com.microsoft.dynamics.customerinsights.apiclient.models.EntitySize;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAListOfMeasuresMetadataHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllDataSourcesHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllEntityMetadataHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllInstancesHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllInstancesInBatchesByInstanceidsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllRelationshipsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllRoleAssignmentsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllRoleDefinitionsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllSegmentsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAnAttributeProfileHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAnEntityProfileHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetARelationshipHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAWorkflowJobInformationHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetCurrentUserRoleHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetDataSourceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetEntitiesWithODataQueryParametersHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetEntityMetadataHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetEntitySizeHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetInstanceMetadataHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetKeyRingHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetListOfRecentWorkflowJobsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetListOfWorkflowTaskInformationHistoryHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetMetadataForAMeasureHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetProfileStoreStateHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetSearchConfigurationHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetSupportedTimezonesHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetWorkflowSchedulesHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetWorkflowStatusHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GraphJobInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.GraphNodeInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.GraphTaskInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.IC360EntityModel;
import com.microsoft.dynamics.customerinsights.apiclient.models.IEntityMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstanceCopyRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstanceCreationRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstanceInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstanceMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstanceSearchConfiguration;
import com.microsoft.dynamics.customerinsights.apiclient.models.MeasureMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.NoContentResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.ODataEntityPayload;
import com.microsoft.dynamics.customerinsights.apiclient.models.ODataError;
import com.microsoft.dynamics.customerinsights.apiclient.models.OnDemandJobRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.ParsingError;
import com.microsoft.dynamics.customerinsights.apiclient.models.ProfileStoreStateInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.RelationshipMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.ResetAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.ResetInstanceForScopeHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.RoleAssignment;
import com.microsoft.dynamics.customerinsights.apiclient.models.RoleDefinition;
import com.microsoft.dynamics.customerinsights.apiclient.models.SegmentMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.SubmitAWorkflowJobHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.TimezoneDetail;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateAMeasureHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateAnEntityHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateARelationshipHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateARoleAssignmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateASegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateSearchConfigurationHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.WorkflowRefreshSchedule;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the CustomerInsights class.
 */
public class CustomerInsightsImpl extends ServiceClient implements CustomerInsights {
    /**
     * The Retrofit service to perform REST calls.
     */
    private CustomerInsightsService service;

    /**
     * Initializes an instance of CustomerInsights client.
     */
    public CustomerInsightsImpl() {
        this("https://api.ci.ai.dynamics.com/v1");
    }

    /**
     * Initializes an instance of CustomerInsights client.
     *
     * @param baseUrl the base URL of the host
     */
    public CustomerInsightsImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of CustomerInsights client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public CustomerInsightsImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https://api.ci.ai.dynamics.com/v1", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of CustomerInsights client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public CustomerInsightsImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of CustomerInsights client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public CustomerInsightsImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(CustomerInsightsService.class);
    }

    /**
     * The interface defining all the services for CustomerInsights to be
     * used by Retrofit to perform actually REST calls.
     */
    interface CustomerInsightsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAnAttributeProfile" })
        @GET("instances/{instanceId}/dataprofile/{qualifiedEntityName}/{attributeName}")
        Observable<Response<ResponseBody>> getAnAttributeProfile(@Path("instanceId") String instanceId, @Path("qualifiedEntityName") String qualifiedEntityName, @Path("attributeName") String attributeName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllDataSources" })
        @GET("instances/{instanceId}/manage/datasources")
        Observable<Response<ResponseBody>> getAllDataSources(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getDataSource" })
        @GET("instances/{instanceId}/manage/datasources/{dataSourceId}")
        Observable<Response<ResponseBody>> getDataSource(@Path("instanceId") String instanceId, @Path("dataSourceId") String dataSourceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteADataSource" })
        @HTTP(path = "instances/{instanceId}/manage/datasources/{dataSourceId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteADataSource(@Path("instanceId") String instanceId, @Path("dataSourceId") String dataSourceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createAnEntity" })
        @POST("instances/{instanceId}/data/{entityName}")
        Observable<Response<ResponseBody>> createAnEntity(@Path("instanceId") String instanceId, @Path("entityName") String entityName, @Body Object body, @Query("validUntil") String validUntil, @Query("caller") String caller);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateAnEntity" })
        @PATCH("instances/{instanceId}/data/{entityName}/{entityId}")
        Observable<Response<ResponseBody>> updateAnEntity(@Path("instanceId") String instanceId, @Path("entityName") String entityName, @Path("entityId") String entityId, @Body Object body, @Query("validUntil") String validUntil, @Query("caller") String caller);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getEntitiesWithODataQueryParameters" })
        @GET("instances/{instanceId}/data")
        Observable<Response<ResponseBody>> getEntitiesWithODataQueryParameters(@Path("instanceId") String instanceId, @Query(value = "relativePath", encoded = true) String relativePath, @Query("forceSearch") Boolean forceSearch, @Query("proxy") Boolean proxy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllEntityMetadata" })
        @GET("instances/{instanceId}/manage/entities")
        Observable<Response<ResponseBody>> getAllEntityMetadata(@Path("instanceId") String instanceId, @Query("attributesAnnotations") Boolean attributesAnnotations, @Query("includeQuarantined") Boolean includeQuarantined);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getEntityMetadata" })
        @GET("instances/{instanceId}/manage/entities/{entityName}")
        Observable<Response<ResponseBody>> getEntityMetadata(@Path("instanceId") String instanceId, @Path("entityName") String entityName, @Query("attributesAnnotations") Boolean attributesAnnotations);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getEntitySize" })
        @GET("instances/{instanceId}/manage/entities/{entityName}/entitysize")
        Observable<Response<ResponseBody>> getEntitySize(@Path("instanceId") String instanceId, @Path("entityName") String entityName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights resetAnInstance" })
        @HTTP(path = "instances/{instanceId}/manage/reset", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> resetAnInstance(@Path("instanceId") String instanceId, @Query("instanceManagementOperationScope") String instanceManagementOperationScope);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights resetInstanceForScope" })
        @HTTP(path = "instances/{instanceId}/manage/reset/operationScope/{instanceManagementOperationScope}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> resetInstanceForScope(@Path("instanceId") String instanceId, @Path("instanceManagementOperationScope") String instanceManagementOperationScope);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllInstances" })
        @GET("instances")
        Observable<Response<ResponseBody>> getAllInstances();

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllInstancesInBatchesByInstanceids" })
        @POST("instances/batch")
        Observable<Response<ResponseBody>> getAllInstancesInBatchesByInstanceids(@Body List<UUID> body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getInstanceMetadata" })
        @GET("instances/{instanceId}")
        Observable<Response<ResponseBody>> getInstanceMetadata(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteAnInstance" })
        @HTTP(path = "instances/{instanceId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAnInstance(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createAnInstance" })
        @POST("instances/V2")
        Observable<Response<ResponseBody>> createAnInstance(@Body InstanceCreationRequest body, @Query("isTrial") Boolean isTrial);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateAnInstance" })
        @PATCH("instances/{instanceId}/V2")
        Observable<Response<ResponseBody>> updateAnInstance(@Path("instanceId") String instanceId, @Body InstanceCreationRequest body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights copyAnInstance" })
        @POST("instances/copy")
        Observable<Response<ResponseBody>> copyAnInstance(@Body InstanceCopyRequest body, @Query("isTrial") Boolean isTrial);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAListOfMeasuresMetadata" })
        @GET("instances/{instanceId}/manage/measures")
        Observable<Response<ResponseBody>> getAListOfMeasuresMetadata(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createAMeasure" })
        @POST("instances/{instanceId}/manage/measures")
        Observable<Response<ResponseBody>> createAMeasure(@Path("instanceId") String instanceId, @Body MeasureMetadata body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getMetadataForAMeasure" })
        @GET("instances/{instanceId}/manage/measures/{measureName}")
        Observable<Response<ResponseBody>> getMetadataForAMeasure(@Path("instanceId") String instanceId, @Path("measureName") String measureName, @Query("includeHistoricStats") Boolean includeHistoricStats, @Query("historicStatsDays") Integer historicStatsDays);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateAMeasure" })
        @PUT("instances/{instanceId}/manage/measures/{measureName}")
        Observable<Response<ResponseBody>> updateAMeasure(@Path("instanceId") String instanceId, @Path("measureName") String measureName, @Body MeasureMetadata body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteAMeasure" })
        @HTTP(path = "instances/{instanceId}/manage/measures/{measureName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAMeasure(@Path("instanceId") String instanceId, @Path("measureName") String measureName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getKeyRing" })
        @GET("instances/{instanceId}/profile/keyring")
        Observable<Response<ResponseBody>> getKeyRing(@Path("instanceId") String instanceId, @Query("dataSourceName") String dataSourceName, @Query("entityName") String entityName, @Query("key") String key);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getProfileStoreState" })
        @GET("instances/{instanceId}/profilestore/stateinfo")
        Observable<Response<ResponseBody>> getProfileStoreState(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllRoleDefinitions" })
        @GET("instances/{instanceId}/rbac/roles")
        Observable<Response<ResponseBody>> getAllRoleDefinitions(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getCurrentUserRole" })
        @GET("instances/{instanceId}/rbac/myrole")
        Observable<Response<ResponseBody>> getCurrentUserRole(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateARoleAssignment" })
        @PUT("instances/{instanceId}/rbac/principals/{principalId}/assignment")
        Observable<Response<ResponseBody>> updateARoleAssignment(@Path("instanceId") String instanceId, @Path("principalId") String principalId, @Body RoleAssignment body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deletesARoleAssignment" })
        @HTTP(path = "instances/{instanceId}/rbac/principals/{principalId}/assignment", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletesARoleAssignment(@Path("instanceId") String instanceId, @Path("principalId") String principalId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllRoleAssignments" })
        @GET("instances/{instanceId}/rbac/assignments")
        Observable<Response<ResponseBody>> getAllRoleAssignments(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllRelationships" })
        @GET("instances/{instanceId}/manage/relationships")
        Observable<Response<ResponseBody>> getAllRelationships(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createARelationship" })
        @POST("instances/{instanceId}/manage/relationships")
        Observable<Response<ResponseBody>> createARelationship(@Path("instanceId") String instanceId, @Body RelationshipMetadata body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getARelationship" })
        @GET("instances/{instanceId}/manage/relationships/{relationshipName}")
        Observable<Response<ResponseBody>> getARelationship(@Path("instanceId") String instanceId, @Path("relationshipName") String relationshipName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteARelationship" })
        @HTTP(path = "instances/{instanceId}/manage/relationships/{relationshipName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteARelationship(@Path("instanceId") String instanceId, @Path("relationshipName") String relationshipName);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateARelationship" })
        @PUT("instances/{instanceId}/manage/relationships/{relationshipName}")
        Observable<Response<ResponseBody>> updateARelationship(@Path("instanceId") String instanceId, @Path("relationshipName") String relationshipName, @Body RelationshipMetadata body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getSearchConfiguration" })
        @GET("instances/{instanceId}/manage/search")
        Observable<Response<ResponseBody>> getSearchConfiguration(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateSearchConfiguration" })
        @PUT("instances/{instanceId}/manage/search")
        Observable<Response<ResponseBody>> updateSearchConfiguration(@Path("instanceId") String instanceId, @Body InstanceSearchConfiguration body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllSegments" })
        @GET("instances/{instanceId}/manage/segments")
        Observable<Response<ResponseBody>> getAllSegments(@Path("instanceId") String instanceId, @Query("includeHistoricStats") Boolean includeHistoricStats, @Query("historicStatsDays") Integer historicStatsDays);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createASegment" })
        @POST("instances/{instanceId}/manage/segments")
        Observable<Response<ResponseBody>> createASegment(@Path("instanceId") String instanceId, @Body SegmentMetadata body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights activateSegment" })
        @PUT("instances/{instanceId}/manage/segments/{segmentName}/activate")
        Observable<Response<ResponseBody>> activateSegment(@Path("instanceId") String instanceId, @Path("segmentName") String segmentName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deactivateSegment" })
        @PUT("instances/{instanceId}/manage/segments/{segmentName}/deactivate")
        Observable<Response<ResponseBody>> deactivateSegment(@Path("instanceId") String instanceId, @Path("segmentName") String segmentName);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateASegment" })
        @PUT("instances/{instanceId}/manage/segments/{segmentName}")
        Observable<Response<ResponseBody>> updateASegment(@Path("instanceId") String instanceId, @Path("segmentName") String segmentName, @Body SegmentMetadata body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteSegment" })
        @HTTP(path = "instances/{instanceId}/manage/segments/{segmentName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSegment(@Path("instanceId") String instanceId, @Path("segmentName") String segmentName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAWorkflowJobInformation" })
        @GET("instances/{instanceId}/workflows/{workflowName}/jobs/{jobId}")
        Observable<Response<ResponseBody>> getAWorkflowJobInformation(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Path("jobId") String jobId, @Query("includeTasks") Boolean includeTasks);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights cancelAWorkflowJob" })
        @POST("instances/{instanceId}/workflows/{workflowName}/jobs/{jobId}/cancel")
        Observable<Response<ResponseBody>> cancelAWorkflowJob(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Path("jobId") String jobId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getListOfRecentWorkflowJobs" })
        @GET("instances/{instanceId}/workflows/{workflowName}/jobs")
        Observable<Response<ResponseBody>> getListOfRecentWorkflowJobs(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Query("top") Integer top, @Query("includeTasks") Boolean includeTasks);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights submitAWorkflowJob" })
        @POST("instances/{instanceId}/workflows/{workflowName}/jobs")
        Observable<Response<ResponseBody>> submitAWorkflowJob(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Body OnDemandJobRequest body, @Query("operationType") String operationType, @Query("identifiers") String identifiers, @Query("forceRunRequested") Boolean forceRunRequested);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getListOfWorkflowTaskInformationHistory" })
        @GET("instances/{instanceId}/workflows/{workflowName}/history")
        Observable<Response<ResponseBody>> getListOfWorkflowTaskInformationHistory(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Query("top") Integer top);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getWorkflowStatus" })
        @GET("instances/{instanceId}/workflows/{workflowName}/status")
        Observable<Response<ResponseBody>> getWorkflowStatus(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getSupportedTimezones" })
        @GET("instances/{instanceId}/workflows/{workflowName}/schedules/supportedTimezones")
        Observable<Response<ResponseBody>> getSupportedTimezones(@Path("workflowName") String workflowName, @Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getWorkflowSchedules" })
        @GET("instances/{instanceId}/workflows/{workflowName}/schedules")
        Observable<Response<ResponseBody>> getWorkflowSchedules(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createWorkflowRefreshSchedule" })
        @POST("instances/{instanceId}/workflows/{workflowName}/schedules")
        Observable<Response<ResponseBody>> createWorkflowRefreshSchedule(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Body WorkflowRefreshSchedule body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAnEntityProfile" })
        @GET("instances/{instanceId}/dataprofile/{qualifiedEntityName}")
        Observable<Response<ResponseBody>> getAnEntityProfile(@Path("instanceId") String instanceId, @Path("qualifiedEntityName") String qualifiedEntityName);

    }

    /**
     * Gets the specific attribute profile for the entity.
     * Gets the specific attribute profile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param attributeName Attribute Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AttributeDataProfile object if successful.
     */
    public AttributeDataProfile getAnAttributeProfile(String instanceId, String qualifiedEntityName, String attributeName) {
        return getAnAttributeProfileWithServiceResponseAsync(instanceId, qualifiedEntityName, attributeName).toBlocking().single().body();
    }

    /**
     * Gets the specific attribute profile for the entity.
     * Gets the specific attribute profile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param attributeName Attribute Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AttributeDataProfile> getAnAttributeProfileAsync(String instanceId, String qualifiedEntityName, String attributeName, final ServiceCallback<AttributeDataProfile> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAnAttributeProfileWithServiceResponseAsync(instanceId, qualifiedEntityName, attributeName), serviceCallback);
    }

    /**
     * Gets the specific attribute profile for the entity.
     * Gets the specific attribute profile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param attributeName Attribute Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AttributeDataProfile object
     */
    public Observable<AttributeDataProfile> getAnAttributeProfileAsync(String instanceId, String qualifiedEntityName, String attributeName) {
        return getAnAttributeProfileWithServiceResponseAsync(instanceId, qualifiedEntityName, attributeName).map(new Func1<ServiceResponseWithHeaders<AttributeDataProfile, GetAnAttributeProfileHeaders>, AttributeDataProfile>() {
            @Override
            public AttributeDataProfile call(ServiceResponseWithHeaders<AttributeDataProfile, GetAnAttributeProfileHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the specific attribute profile for the entity.
     * Gets the specific attribute profile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param attributeName Attribute Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AttributeDataProfile object
     */
    public Observable<ServiceResponseWithHeaders<AttributeDataProfile, GetAnAttributeProfileHeaders>> getAnAttributeProfileWithServiceResponseAsync(String instanceId, String qualifiedEntityName, String attributeName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (qualifiedEntityName == null) {
            throw new IllegalArgumentException("Parameter qualifiedEntityName is required and cannot be null.");
        }
        if (attributeName == null) {
            throw new IllegalArgumentException("Parameter attributeName is required and cannot be null.");
        }
        return service.getAnAttributeProfile(instanceId, qualifiedEntityName, attributeName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<AttributeDataProfile, GetAnAttributeProfileHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<AttributeDataProfile, GetAnAttributeProfileHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<AttributeDataProfile, GetAnAttributeProfileHeaders> clientResponse = getAnAttributeProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<AttributeDataProfile, GetAnAttributeProfileHeaders> getAnAttributeProfileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<AttributeDataProfile, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<AttributeDataProfile>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAnAttributeProfileHeaders.class);
    }

    /**
     * Fetches a collection of DataSourceInfo configured for the Customer Insights instance.
     * Fetches a collection of DataSourceInfo configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id for which to fetch data source info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllDataSources(String instanceId) {
        return getAllDataSourcesWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Fetches a collection of DataSourceInfo configured for the Customer Insights instance.
     * Fetches a collection of DataSourceInfo configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id for which to fetch data source info.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllDataSourcesAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllDataSourcesWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Fetches a collection of DataSourceInfo configured for the Customer Insights instance.
     * Fetches a collection of DataSourceInfo configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id for which to fetch data source info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllDataSourcesAsync(String instanceId) {
        return getAllDataSourcesWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Fetches a collection of DataSourceInfo configured for the Customer Insights instance.
     * Fetches a collection of DataSourceInfo configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id for which to fetch data source info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders>> getAllDataSourcesWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllDataSources(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders> clientResponse = getAllDataSourcesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders> getAllDataSourcesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DataSourceInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllDataSourcesHeaders.class);
    }

    /**
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id to fetch data source info for.
     * @param dataSourceId Format - uuid. The data source id to fetch info for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getDataSource(String instanceId, String dataSourceId) {
        return getDataSourceWithServiceResponseAsync(instanceId, dataSourceId).toBlocking().single().body();
    }

    /**
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id to fetch data source info for.
     * @param dataSourceId Format - uuid. The data source id to fetch info for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getDataSourceAsync(String instanceId, String dataSourceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getDataSourceWithServiceResponseAsync(instanceId, dataSourceId), serviceCallback);
    }

    /**
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id to fetch data source info for.
     * @param dataSourceId Format - uuid. The data source id to fetch info for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getDataSourceAsync(String instanceId, String dataSourceId) {
        return getDataSourceWithServiceResponseAsync(instanceId, dataSourceId).map(new Func1<ServiceResponseWithHeaders<Object, GetDataSourceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetDataSourceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id to fetch data source info for.
     * @param dataSourceId Format - uuid. The data source id to fetch info for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetDataSourceHeaders>> getDataSourceWithServiceResponseAsync(String instanceId, String dataSourceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (dataSourceId == null) {
            throw new IllegalArgumentException("Parameter dataSourceId is required and cannot be null.");
        }
        return service.getDataSource(instanceId, dataSourceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetDataSourceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetDataSourceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetDataSourceHeaders> clientResponse = getDataSourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetDataSourceHeaders> getDataSourceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DataSourceInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetDataSourceHeaders.class);
    }

    /**
     * Deletes a data source from the instance.
     * Deletes a data source from the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param dataSourceId Format - uuid. The data source id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteADataSource(String instanceId, String dataSourceId) {
        return deleteADataSourceWithServiceResponseAsync(instanceId, dataSourceId).toBlocking().single().body();
    }

    /**
     * Deletes a data source from the instance.
     * Deletes a data source from the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param dataSourceId Format - uuid. The data source id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteADataSourceAsync(String instanceId, String dataSourceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteADataSourceWithServiceResponseAsync(instanceId, dataSourceId), serviceCallback);
    }

    /**
     * Deletes a data source from the instance.
     * Deletes a data source from the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param dataSourceId Format - uuid. The data source id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteADataSourceAsync(String instanceId, String dataSourceId) {
        return deleteADataSourceWithServiceResponseAsync(instanceId, dataSourceId).map(new Func1<ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a data source from the instance.
     * Deletes a data source from the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param dataSourceId Format - uuid. The data source id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders>> deleteADataSourceWithServiceResponseAsync(String instanceId, String dataSourceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (dataSourceId == null) {
            throw new IllegalArgumentException("Parameter dataSourceId is required and cannot be null.");
        }
        return service.deleteADataSource(instanceId, dataSourceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders> clientResponse = deleteADataSourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders> deleteADataSourceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeletionResponse>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeleteADataSourceHeaders.class);
    }

    /**
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAnEntity(String instanceId, String entityName) {
        return createAnEntityWithServiceResponseAsync(instanceId, entityName).toBlocking().single().body();
    }

    /**
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAnEntityAsync(String instanceId, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAnEntityWithServiceResponseAsync(instanceId, entityName), serviceCallback);
    }

    /**
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAnEntityAsync(String instanceId, String entityName) {
        return createAnEntityWithServiceResponseAsync(instanceId, entityName).map(new Func1<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>> createAnEntityWithServiceResponseAsync(String instanceId, String entityName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        final Object body = null;
        final String validUntil = null;
        final String caller = null;
        return service.createAnEntity(instanceId, entityName, body, validUntil, caller)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> clientResponse = createAnEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param body JSON document representing the entity. The schema must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAnEntity(String instanceId, String entityName, Object body, String validUntil, String caller) {
        return createAnEntityWithServiceResponseAsync(instanceId, entityName, body, validUntil, caller).toBlocking().single().body();
    }

    /**
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param body JSON document representing the entity. The schema must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAnEntityAsync(String instanceId, String entityName, Object body, String validUntil, String caller, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAnEntityWithServiceResponseAsync(instanceId, entityName, body, validUntil, caller), serviceCallback);
    }

    /**
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param body JSON document representing the entity. The schema must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAnEntityAsync(String instanceId, String entityName, Object body, String validUntil, String caller) {
        return createAnEntityWithServiceResponseAsync(instanceId, entityName, body, validUntil, caller).map(new Func1<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     * Writes an entity instance into the store, g. an activity entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param body JSON document representing the entity. The schema must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>> createAnEntityWithServiceResponseAsync(String instanceId, String entityName, Object body, String validUntil, String caller) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        return service.createAnEntity(instanceId, entityName, body, validUntil, caller)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> clientResponse = createAnEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> createAnEntityDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<CreatedResult>() { }.getType())
                .register(202, new TypeToken<AcceptedResult>() { }.getType())
                .register(400, new TypeToken<ODataError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<ODataError>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateAnEntityHeaders.class);
    }

    /**
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAnEntity(String instanceId, String entityName, String entityId) {
        return updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId).toBlocking().single().body();
    }

    /**
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAnEntityAsync(String instanceId, String entityName, String entityId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId), serviceCallback);
    }

    /**
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAnEntityAsync(String instanceId, String entityName, String entityId) {
        return updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>> updateAnEntityWithServiceResponseAsync(String instanceId, String entityName, String entityId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final Object body = null;
        final String validUntil = null;
        final String caller = null;
        return service.updateAnEntity(instanceId, entityName, entityId, body, validUntil, caller)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> clientResponse = updateAnEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param body JSON document with set of changes to apply on the entity. Each change must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAnEntity(String instanceId, String entityName, String entityId, Object body, String validUntil, String caller) {
        return updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId, body, validUntil, caller).toBlocking().single().body();
    }

    /**
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param body JSON document with set of changes to apply on the entity. Each change must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAnEntityAsync(String instanceId, String entityName, String entityId, Object body, String validUntil, String caller, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId, body, validUntil, caller), serviceCallback);
    }

    /**
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param body JSON document with set of changes to apply on the entity. Each change must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAnEntityAsync(String instanceId, String entityName, String entityId, Object body, String validUntil, String caller) {
        return updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId, body, validUntil, caller).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     * Updates an entity instance in the store, g. Customer entity. (Preview).
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param body JSON document with set of changes to apply on the entity. Each change must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>> updateAnEntityWithServiceResponseAsync(String instanceId, String entityName, String entityId, Object body, String validUntil, String caller) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        return service.updateAnEntity(instanceId, entityName, entityId, body, validUntil, caller)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> clientResponse = updateAnEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> updateAnEntityDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<NoContentResult>() { }.getType())
                .register(400, new TypeToken<ODataError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ODataError>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateAnEntityHeaders.class);
    }

    /**
     * Submits an OData request to the service.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntitiesWithODataQueryParameters(String instanceId) {
        return getEntitiesWithODataQueryParametersWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Submits an OData request to the service.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntitiesWithODataQueryParametersAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntitiesWithODataQueryParametersWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Submits an OData request to the service.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntitiesWithODataQueryParametersAsync(String instanceId) {
        return getEntitiesWithODataQueryParametersWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Submits an OData request to the service.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders>> getEntitiesWithODataQueryParametersWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final String relativePath = null;
        final Boolean forceSearch = null;
        final Boolean proxy = null;
        return service.getEntitiesWithODataQueryParameters(instanceId, relativePath, forceSearch, proxy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders> clientResponse = getEntitiesWithODataQueryParametersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Submits an OData request to the service.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param forceSearch Whether force use search to support the query.
     * @param proxy Whether or not we are requesting data by proxy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntitiesWithODataQueryParameters(String instanceId, String relativePath, Boolean forceSearch, Boolean proxy) {
        return getEntitiesWithODataQueryParametersWithServiceResponseAsync(instanceId, relativePath, forceSearch, proxy).toBlocking().single().body();
    }

    /**
     * Submits an OData request to the service.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param forceSearch Whether force use search to support the query.
     * @param proxy Whether or not we are requesting data by proxy.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntitiesWithODataQueryParametersAsync(String instanceId, String relativePath, Boolean forceSearch, Boolean proxy, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntitiesWithODataQueryParametersWithServiceResponseAsync(instanceId, relativePath, forceSearch, proxy), serviceCallback);
    }

    /**
     * Submits an OData request to the service.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param forceSearch Whether force use search to support the query.
     * @param proxy Whether or not we are requesting data by proxy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntitiesWithODataQueryParametersAsync(String instanceId, String relativePath, Boolean forceSearch, Boolean proxy) {
        return getEntitiesWithODataQueryParametersWithServiceResponseAsync(instanceId, relativePath, forceSearch, proxy).map(new Func1<ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Submits an OData request to the service.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param forceSearch Whether force use search to support the query.
     * @param proxy Whether or not we are requesting data by proxy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders>> getEntitiesWithODataQueryParametersWithServiceResponseAsync(String instanceId, String relativePath, Boolean forceSearch, Boolean proxy) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getEntitiesWithODataQueryParameters(instanceId, relativePath, forceSearch, proxy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders> clientResponse = getEntitiesWithODataQueryParametersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEntitiesWithODataQueryParametersHeaders> getEntitiesWithODataQueryParametersDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ODataEntityPayload>() { }.getType())
                .register(400, new TypeToken<ODataError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ODataError>() { }.getType())
                .register(500, new TypeToken<ODataError>() { }.getType())
                .register(503, new TypeToken<ODataError>() { }.getType())
                .buildWithHeaders(response, GetEntitiesWithODataQueryParametersHeaders.class);
    }

    /**
     * Retrieves the flattened entity model for the provided instanceId.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllEntityMetadata(String instanceId) {
        return getAllEntityMetadataWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Retrieves the flattened entity model for the provided instanceId.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllEntityMetadataAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllEntityMetadataWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Retrieves the flattened entity model for the provided instanceId.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllEntityMetadataAsync(String instanceId) {
        return getAllEntityMetadataWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the flattened entity model for the provided instanceId.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>> getAllEntityMetadataWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final Boolean attributesAnnotations = null;
        final Boolean includeQuarantined = null;
        return service.getAllEntityMetadata(instanceId, attributesAnnotations, includeQuarantined)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> clientResponse = getAllEntityMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the flattened entity model for the provided instanceId.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param includeQuarantined Indicates if quarantined entities should be included in the output entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllEntityMetadata(String instanceId, Boolean attributesAnnotations, Boolean includeQuarantined) {
        return getAllEntityMetadataWithServiceResponseAsync(instanceId, attributesAnnotations, includeQuarantined).toBlocking().single().body();
    }

    /**
     * Retrieves the flattened entity model for the provided instanceId.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param includeQuarantined Indicates if quarantined entities should be included in the output entity model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllEntityMetadataAsync(String instanceId, Boolean attributesAnnotations, Boolean includeQuarantined, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllEntityMetadataWithServiceResponseAsync(instanceId, attributesAnnotations, includeQuarantined), serviceCallback);
    }

    /**
     * Retrieves the flattened entity model for the provided instanceId.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param includeQuarantined Indicates if quarantined entities should be included in the output entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllEntityMetadataAsync(String instanceId, Boolean attributesAnnotations, Boolean includeQuarantined) {
        return getAllEntityMetadataWithServiceResponseAsync(instanceId, attributesAnnotations, includeQuarantined).map(new Func1<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the flattened entity model for the provided instanceId.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param includeQuarantined Indicates if quarantined entities should be included in the output entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>> getAllEntityMetadataWithServiceResponseAsync(String instanceId, Boolean attributesAnnotations, Boolean includeQuarantined) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllEntityMetadata(instanceId, attributesAnnotations, includeQuarantined)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> clientResponse = getAllEntityMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> getAllEntityMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IC360EntityModel>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetAllEntityMetadataHeaders.class);
    }

    /**
     * Retrieves the entity metadata for the provided instanceId and entityName.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntityMetadata(String instanceId, String entityName) {
        return getEntityMetadataWithServiceResponseAsync(instanceId, entityName).toBlocking().single().body();
    }

    /**
     * Retrieves the entity metadata for the provided instanceId and entityName.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntityMetadataAsync(String instanceId, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntityMetadataWithServiceResponseAsync(instanceId, entityName), serviceCallback);
    }

    /**
     * Retrieves the entity metadata for the provided instanceId and entityName.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntityMetadataAsync(String instanceId, String entityName) {
        return getEntityMetadataWithServiceResponseAsync(instanceId, entityName).map(new Func1<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the entity metadata for the provided instanceId and entityName.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>> getEntityMetadataWithServiceResponseAsync(String instanceId, String entityName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        final Boolean attributesAnnotations = null;
        return service.getEntityMetadata(instanceId, entityName, attributesAnnotations)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> clientResponse = getEntityMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the entity metadata for the provided instanceId and entityName.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntityMetadata(String instanceId, String entityName, Boolean attributesAnnotations) {
        return getEntityMetadataWithServiceResponseAsync(instanceId, entityName, attributesAnnotations).toBlocking().single().body();
    }

    /**
     * Retrieves the entity metadata for the provided instanceId and entityName.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntityMetadataAsync(String instanceId, String entityName, Boolean attributesAnnotations, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntityMetadataWithServiceResponseAsync(instanceId, entityName, attributesAnnotations), serviceCallback);
    }

    /**
     * Retrieves the entity metadata for the provided instanceId and entityName.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntityMetadataAsync(String instanceId, String entityName, Boolean attributesAnnotations) {
        return getEntityMetadataWithServiceResponseAsync(instanceId, entityName, attributesAnnotations).map(new Func1<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the entity metadata for the provided instanceId and entityName.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>> getEntityMetadataWithServiceResponseAsync(String instanceId, String entityName, Boolean attributesAnnotations) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        return service.getEntityMetadata(instanceId, entityName, attributesAnnotations)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> clientResponse = getEntityMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> getEntityMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IEntityMetadata>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetEntityMetadataHeaders.class);
    }

    /**
     * Retrieves the entity size for the provided instanceId and entityName.
     * Retrieves the entity size for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntitySize(String instanceId, String entityName) {
        return getEntitySizeWithServiceResponseAsync(instanceId, entityName).toBlocking().single().body();
    }

    /**
     * Retrieves the entity size for the provided instanceId and entityName.
     * Retrieves the entity size for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntitySizeAsync(String instanceId, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntitySizeWithServiceResponseAsync(instanceId, entityName), serviceCallback);
    }

    /**
     * Retrieves the entity size for the provided instanceId and entityName.
     * Retrieves the entity size for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntitySizeAsync(String instanceId, String entityName) {
        return getEntitySizeWithServiceResponseAsync(instanceId, entityName).map(new Func1<ServiceResponseWithHeaders<Object, GetEntitySizeHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntitySizeHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the entity size for the provided instanceId and entityName.
     * Retrieves the entity size for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntitySizeHeaders>> getEntitySizeWithServiceResponseAsync(String instanceId, String entityName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        return service.getEntitySize(instanceId, entityName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntitySizeHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntitySizeHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntitySizeHeaders> clientResponse = getEntitySizeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEntitySizeHeaders> getEntitySizeDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntitySize>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<ApiError>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetEntitySizeHeaders.class);
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object resetAnInstance(String instanceId) {
        return resetAnInstanceWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> resetAnInstanceAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(resetAnInstanceWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> resetAnInstanceAsync(String instanceId) {
        return resetAnInstanceWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>> resetAnInstanceWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final String instanceManagementOperationScope = null;
        return service.resetAnInstance(instanceId, instanceManagementOperationScope)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> clientResponse = resetAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object resetAnInstance(String instanceId, String instanceManagementOperationScope) {
        return resetAnInstanceWithServiceResponseAsync(instanceId, instanceManagementOperationScope).toBlocking().single().body();
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> resetAnInstanceAsync(String instanceId, String instanceManagementOperationScope, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(resetAnInstanceWithServiceResponseAsync(instanceId, instanceManagementOperationScope), serviceCallback);
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> resetAnInstanceAsync(String instanceId, String instanceManagementOperationScope) {
        return resetAnInstanceWithServiceResponseAsync(instanceId, instanceManagementOperationScope).map(new Func1<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>> resetAnInstanceWithServiceResponseAsync(String instanceId, String instanceManagementOperationScope) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.resetAnInstance(instanceId, instanceManagementOperationScope)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> clientResponse = resetAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> resetAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ResetAnInstanceHeaders.class);
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object resetInstanceForScope(String instanceId, String instanceManagementOperationScope) {
        return resetInstanceForScopeWithServiceResponseAsync(instanceId, instanceManagementOperationScope).toBlocking().single().body();
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> resetInstanceForScopeAsync(String instanceId, String instanceManagementOperationScope, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(resetInstanceForScopeWithServiceResponseAsync(instanceId, instanceManagementOperationScope), serviceCallback);
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> resetInstanceForScopeAsync(String instanceId, String instanceManagementOperationScope) {
        return resetInstanceForScopeWithServiceResponseAsync(instanceId, instanceManagementOperationScope).map(new Func1<ServiceResponseWithHeaders<Object, ResetInstanceForScopeHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, ResetInstanceForScopeHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope. (Preview).
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, ResetInstanceForScopeHeaders>> resetInstanceForScopeWithServiceResponseAsync(String instanceId, String instanceManagementOperationScope) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (instanceManagementOperationScope == null) {
            throw new IllegalArgumentException("Parameter instanceManagementOperationScope is required and cannot be null.");
        }
        return service.resetInstanceForScope(instanceId, instanceManagementOperationScope)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, ResetInstanceForScopeHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, ResetInstanceForScopeHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, ResetInstanceForScopeHeaders> clientResponse = resetInstanceForScopeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, ResetInstanceForScopeHeaders> resetInstanceForScopeDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ResetInstanceForScopeHeaders.class);
    }

    /**
     * Retrieves all instances of the current user.
     * Retrieves all instances of the current user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllInstances() {
        return getAllInstancesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Retrieves all instances of the current user.
     * Retrieves all instances of the current user.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllInstancesAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllInstancesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Retrieves all instances of the current user.
     * Retrieves all instances of the current user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllInstancesAsync() {
        return getAllInstancesWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetAllInstancesHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllInstancesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves all instances of the current user.
     * Retrieves all instances of the current user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesHeaders>> getAllInstancesWithServiceResponseAsync() {
        return service.getAllInstances()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllInstancesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllInstancesHeaders> clientResponse = getAllInstancesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllInstancesHeaders> getAllInstancesDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<InstanceInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllInstancesHeaders.class);
    }

    /**
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllInstancesInBatchesByInstanceids() {
        return getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllInstancesInBatchesByInstanceidsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllInstancesInBatchesByInstanceidsAsync() {
        return getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>> getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync() {
        final List<UUID> body = null;
        return service.getAllInstancesInBatchesByInstanceids(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> clientResponse = getAllInstancesInBatchesByInstanceidsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param body Instance ids of instances to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllInstancesInBatchesByInstanceids(List<UUID> body) {
        return getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param body Instance ids of instances to get.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllInstancesInBatchesByInstanceidsAsync(List<UUID> body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param body Instance ids of instances to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllInstancesInBatchesByInstanceidsAsync(List<UUID> body) {
        return getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(body).map(new Func1<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param body Instance ids of instances to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>> getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(List<UUID> body) {
        Validator.validate(body);
        return service.getAllInstancesInBatchesByInstanceids(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> clientResponse = getAllInstancesInBatchesByInstanceidsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> getAllInstancesInBatchesByInstanceidsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<InstanceInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllInstancesInBatchesByInstanceidsHeaders.class);
    }

    /**
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     *
     * @param instanceId Format - uuid. Unique id for the Customer Insights instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getInstanceMetadata(String instanceId) {
        return getInstanceMetadataWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     *
     * @param instanceId Format - uuid. Unique id for the Customer Insights instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getInstanceMetadataAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getInstanceMetadataWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     *
     * @param instanceId Format - uuid. Unique id for the Customer Insights instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getInstanceMetadataAsync(String instanceId) {
        return getInstanceMetadataWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     *
     * @param instanceId Format - uuid. Unique id for the Customer Insights instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders>> getInstanceMetadataWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getInstanceMetadata(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders> clientResponse = getInstanceMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders> getInstanceMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetInstanceMetadataHeaders.class);
    }

    /**
     * Detele an instance.
     * Detele an instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteAnInstance(String instanceId) {
        return deleteAnInstanceWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Detele an instance.
     * Detele an instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteAnInstanceAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteAnInstanceWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Detele an instance.
     * Detele an instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAnInstanceAsync(String instanceId) {
        return deleteAnInstanceWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Detele an instance.
     * Detele an instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders>> deleteAnInstanceWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.deleteAnInstance(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders> clientResponse = deleteAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders> deleteAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeleteAnInstanceHeaders.class);
    }

    /**
     * Creates a new instance.
     * Creates a new instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAnInstance() {
        return createAnInstanceWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Creates a new instance.
     * Creates a new instance.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAnInstanceAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAnInstanceWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Creates a new instance.
     * Creates a new instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAnInstanceAsync() {
        return createAnInstanceWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new instance.
     * Creates a new instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>> createAnInstanceWithServiceResponseAsync() {
        final InstanceCreationRequest body = null;
        final Boolean isTrial = null;
        return service.createAnInstance(body, isTrial)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> clientResponse = createAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new instance.
     * Creates a new instance.
     *
     * @param body The instance creation request.
     * @param isTrial True if the new instance is a trial instance. False otherwise.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAnInstance(InstanceCreationRequest body, Boolean isTrial) {
        return createAnInstanceWithServiceResponseAsync(body, isTrial).toBlocking().single().body();
    }

    /**
     * Creates a new instance.
     * Creates a new instance.
     *
     * @param body The instance creation request.
     * @param isTrial True if the new instance is a trial instance. False otherwise.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAnInstanceAsync(InstanceCreationRequest body, Boolean isTrial, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAnInstanceWithServiceResponseAsync(body, isTrial), serviceCallback);
    }

    /**
     * Creates a new instance.
     * Creates a new instance.
     *
     * @param body The instance creation request.
     * @param isTrial True if the new instance is a trial instance. False otherwise.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAnInstanceAsync(InstanceCreationRequest body, Boolean isTrial) {
        return createAnInstanceWithServiceResponseAsync(body, isTrial).map(new Func1<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new instance.
     * Creates a new instance.
     *
     * @param body The instance creation request.
     * @param isTrial True if the new instance is a trial instance. False otherwise.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>> createAnInstanceWithServiceResponseAsync(InstanceCreationRequest body, Boolean isTrial) {
        Validator.validate(body);
        return service.createAnInstance(body, isTrial)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> clientResponse = createAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> createAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceMetadata>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(409, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateAnInstanceHeaders.class);
    }

    /**
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAnInstance(String instanceId) {
        return updateAnInstanceWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAnInstanceAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAnInstanceWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAnInstanceAsync(String instanceId) {
        return updateAnInstanceWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>> updateAnInstanceWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final InstanceCreationRequest body = null;
        return service.updateAnInstance(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> clientResponse = updateAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param body the InstanceCreationRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAnInstance(String instanceId, InstanceCreationRequest body) {
        return updateAnInstanceWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param body the InstanceCreationRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAnInstanceAsync(String instanceId, InstanceCreationRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAnInstanceWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param body the InstanceCreationRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAnInstanceAsync(String instanceId, InstanceCreationRequest body) {
        return updateAnInstanceWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param body the InstanceCreationRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>> updateAnInstanceWithServiceResponseAsync(String instanceId, InstanceCreationRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateAnInstance(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> clientResponse = updateAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> updateAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceMetadata>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateAnInstanceHeaders.class);
    }

    /**
     * Create a new instance and copy metadata from an existing instance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object copyAnInstance() {
        return copyAnInstanceWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Create a new instance and copy metadata from an existing instance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> copyAnInstanceAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(copyAnInstanceWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Create a new instance and copy metadata from an existing instance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> copyAnInstanceAsync() {
        return copyAnInstanceWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a new instance and copy metadata from an existing instance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>> copyAnInstanceWithServiceResponseAsync() {
        final InstanceCopyRequest body = null;
        final Boolean isTrial = null;
        return service.copyAnInstance(body, isTrial)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> clientResponse = copyAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create a new instance and copy metadata from an existing instance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param body The metadata to use to create the new instance.
     * @param isTrial True if the new instance is a trial instance. False otherwise.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object copyAnInstance(InstanceCopyRequest body, Boolean isTrial) {
        return copyAnInstanceWithServiceResponseAsync(body, isTrial).toBlocking().single().body();
    }

    /**
     * Create a new instance and copy metadata from an existing instance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param body The metadata to use to create the new instance.
     * @param isTrial True if the new instance is a trial instance. False otherwise.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> copyAnInstanceAsync(InstanceCopyRequest body, Boolean isTrial, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(copyAnInstanceWithServiceResponseAsync(body, isTrial), serviceCallback);
    }

    /**
     * Create a new instance and copy metadata from an existing instance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param body The metadata to use to create the new instance.
     * @param isTrial True if the new instance is a trial instance. False otherwise.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> copyAnInstanceAsync(InstanceCopyRequest body, Boolean isTrial) {
        return copyAnInstanceWithServiceResponseAsync(body, isTrial).map(new Func1<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a new instance and copy metadata from an existing instance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param body The metadata to use to create the new instance.
     * @param isTrial True if the new instance is a trial instance. False otherwise.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>> copyAnInstanceWithServiceResponseAsync(InstanceCopyRequest body, Boolean isTrial) {
        Validator.validate(body);
        return service.copyAnInstance(body, isTrial)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> clientResponse = copyAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> copyAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceMetadata>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(409, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CopyAnInstanceHeaders.class);
    }

    /**
     * Retrieves a list of measures metadata for the provided instanceId.
     * Retrieves a list of measures metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAListOfMeasuresMetadata(String instanceId) {
        return getAListOfMeasuresMetadataWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Retrieves a list of measures metadata for the provided instanceId.
     * Retrieves a list of measures metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAListOfMeasuresMetadataAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAListOfMeasuresMetadataWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Retrieves a list of measures metadata for the provided instanceId.
     * Retrieves a list of measures metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAListOfMeasuresMetadataAsync(String instanceId) {
        return getAListOfMeasuresMetadataWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a list of measures metadata for the provided instanceId.
     * Retrieves a list of measures metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders>> getAListOfMeasuresMetadataWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAListOfMeasuresMetadata(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders> clientResponse = getAListOfMeasuresMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders> getAListOfMeasuresMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<MeasureMetadata>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAListOfMeasuresMetadataHeaders.class);
    }

    /**
     * Create new measure metadata with measureMetadata on instanceId.
     * Create new measure metadata with measureMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAMeasure(String instanceId) {
        return createAMeasureWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Create new measure metadata with measureMetadata on instanceId.
     * Create new measure metadata with measureMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAMeasureAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAMeasureWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Create new measure metadata with measureMetadata on instanceId.
     * Create new measure metadata with measureMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAMeasureAsync(String instanceId) {
        return createAMeasureWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create new measure metadata with measureMetadata on instanceId.
     * Create new measure metadata with measureMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>> createAMeasureWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final MeasureMetadata body = null;
        return service.createAMeasure(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> clientResponse = createAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create new measure metadata with measureMetadata on instanceId.
     * Create new measure metadata with measureMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Measure metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAMeasure(String instanceId, MeasureMetadata body) {
        return createAMeasureWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * Create new measure metadata with measureMetadata on instanceId.
     * Create new measure metadata with measureMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Measure metadata to be created
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAMeasureAsync(String instanceId, MeasureMetadata body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAMeasureWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * Create new measure metadata with measureMetadata on instanceId.
     * Create new measure metadata with measureMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Measure metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAMeasureAsync(String instanceId, MeasureMetadata body) {
        return createAMeasureWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create new measure metadata with measureMetadata on instanceId.
     * Create new measure metadata with measureMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Measure metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>> createAMeasureWithServiceResponseAsync(String instanceId, MeasureMetadata body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createAMeasure(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> clientResponse = createAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> createAMeasureDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MeasureMetadata>() { }.getType())
                .register(400, new TypeToken<ParsingError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateAMeasureHeaders.class);
    }

    /**
     * Retrieves the measure metadata for the provided instanceId and measureName.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getMetadataForAMeasure(String instanceId, String measureName) {
        return getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName).toBlocking().single().body();
    }

    /**
     * Retrieves the measure metadata for the provided instanceId and measureName.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getMetadataForAMeasureAsync(String instanceId, String measureName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName), serviceCallback);
    }

    /**
     * Retrieves the measure metadata for the provided instanceId and measureName.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getMetadataForAMeasureAsync(String instanceId, String measureName) {
        return getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName).map(new Func1<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the measure metadata for the provided instanceId and measureName.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>> getMetadataForAMeasureWithServiceResponseAsync(String instanceId, String measureName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        final Boolean includeHistoricStats = null;
        final Integer historicStatsDays = null;
        return service.getMetadataForAMeasure(instanceId, measureName, includeHistoricStats, historicStatsDays)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> clientResponse = getMetadataForAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the measure metadata for the provided instanceId and measureName.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param includeHistoricStats Boolean for historical stats
     * @param historicStatsDays Format - int32. Number of lookback days
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getMetadataForAMeasure(String instanceId, String measureName, Boolean includeHistoricStats, Integer historicStatsDays) {
        return getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName, includeHistoricStats, historicStatsDays).toBlocking().single().body();
    }

    /**
     * Retrieves the measure metadata for the provided instanceId and measureName.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param includeHistoricStats Boolean for historical stats
     * @param historicStatsDays Format - int32. Number of lookback days
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getMetadataForAMeasureAsync(String instanceId, String measureName, Boolean includeHistoricStats, Integer historicStatsDays, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName, includeHistoricStats, historicStatsDays), serviceCallback);
    }

    /**
     * Retrieves the measure metadata for the provided instanceId and measureName.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param includeHistoricStats Boolean for historical stats
     * @param historicStatsDays Format - int32. Number of lookback days
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getMetadataForAMeasureAsync(String instanceId, String measureName, Boolean includeHistoricStats, Integer historicStatsDays) {
        return getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName, includeHistoricStats, historicStatsDays).map(new Func1<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the measure metadata for the provided instanceId and measureName.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param includeHistoricStats Boolean for historical stats
     * @param historicStatsDays Format - int32. Number of lookback days
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>> getMetadataForAMeasureWithServiceResponseAsync(String instanceId, String measureName, Boolean includeHistoricStats, Integer historicStatsDays) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        return service.getMetadataForAMeasure(instanceId, measureName, includeHistoricStats, historicStatsDays)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> clientResponse = getMetadataForAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> getMetadataForAMeasureDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MeasureMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetMetadataForAMeasureHeaders.class);
    }

    /**
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAMeasure(String instanceId, String measureName) {
        return updateAMeasureWithServiceResponseAsync(instanceId, measureName).toBlocking().single().body();
    }

    /**
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAMeasureAsync(String instanceId, String measureName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAMeasureWithServiceResponseAsync(instanceId, measureName), serviceCallback);
    }

    /**
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAMeasureAsync(String instanceId, String measureName) {
        return updateAMeasureWithServiceResponseAsync(instanceId, measureName).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>> updateAMeasureWithServiceResponseAsync(String instanceId, String measureName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        final MeasureMetadata body = null;
        return service.updateAMeasure(instanceId, measureName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> clientResponse = updateAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param body Update measure metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAMeasure(String instanceId, String measureName, MeasureMetadata body) {
        return updateAMeasureWithServiceResponseAsync(instanceId, measureName, body).toBlocking().single().body();
    }

    /**
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param body Update measure metadata
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAMeasureAsync(String instanceId, String measureName, MeasureMetadata body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAMeasureWithServiceResponseAsync(instanceId, measureName, body), serviceCallback);
    }

    /**
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param body Update measure metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAMeasureAsync(String instanceId, String measureName, MeasureMetadata body) {
        return updateAMeasureWithServiceResponseAsync(instanceId, measureName, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param body Update measure metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>> updateAMeasureWithServiceResponseAsync(String instanceId, String measureName, MeasureMetadata body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateAMeasure(instanceId, measureName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> clientResponse = updateAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> updateAMeasureDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MeasureMetadata>() { }.getType())
                .register(400, new TypeToken<ParsingError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateAMeasureHeaders.class);
    }

    /**
     * Deletes the measure metadata for the provided instanceId using measureName.
     * Deletes the measure metadata for the provided instanceId using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteAMeasure(String instanceId, String measureName) {
        return deleteAMeasureWithServiceResponseAsync(instanceId, measureName).toBlocking().single().body();
    }

    /**
     * Deletes the measure metadata for the provided instanceId using measureName.
     * Deletes the measure metadata for the provided instanceId using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteAMeasureAsync(String instanceId, String measureName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteAMeasureWithServiceResponseAsync(instanceId, measureName), serviceCallback);
    }

    /**
     * Deletes the measure metadata for the provided instanceId using measureName.
     * Deletes the measure metadata for the provided instanceId using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAMeasureAsync(String instanceId, String measureName) {
        return deleteAMeasureWithServiceResponseAsync(instanceId, measureName).map(new Func1<ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the measure metadata for the provided instanceId using measureName.
     * Deletes the measure metadata for the provided instanceId using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders>> deleteAMeasureWithServiceResponseAsync(String instanceId, String measureName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        return service.deleteAMeasure(instanceId, measureName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders> clientResponse = deleteAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders> deleteAMeasureDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeletionResponse>() { }.getType())
                .register(400, new TypeToken<DeletionResponse>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeleteAMeasureHeaders.class);
    }

    /**
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     *
     * @param instanceId Format - uuid. Identifier for the instance
     * @param dataSourceName The name of the datasource that contains the given entity.
     * @param entityName The name of the entity that contains the given key.
     * @param key The value of the alternate key provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApiErrorResult object if successful.
     */
    public ApiErrorResult getKeyRing(String instanceId, String dataSourceName, String entityName, String key) {
        return getKeyRingWithServiceResponseAsync(instanceId, dataSourceName, entityName, key).toBlocking().single().body();
    }

    /**
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     *
     * @param instanceId Format - uuid. Identifier for the instance
     * @param dataSourceName The name of the datasource that contains the given entity.
     * @param entityName The name of the entity that contains the given key.
     * @param key The value of the alternate key provided.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApiErrorResult> getKeyRingAsync(String instanceId, String dataSourceName, String entityName, String key, final ServiceCallback<ApiErrorResult> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getKeyRingWithServiceResponseAsync(instanceId, dataSourceName, entityName, key), serviceCallback);
    }

    /**
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     *
     * @param instanceId Format - uuid. Identifier for the instance
     * @param dataSourceName The name of the datasource that contains the given entity.
     * @param entityName The name of the entity that contains the given key.
     * @param key The value of the alternate key provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApiErrorResult object
     */
    public Observable<ApiErrorResult> getKeyRingAsync(String instanceId, String dataSourceName, String entityName, String key) {
        return getKeyRingWithServiceResponseAsync(instanceId, dataSourceName, entityName, key).map(new Func1<ServiceResponseWithHeaders<ApiErrorResult, GetKeyRingHeaders>, ApiErrorResult>() {
            @Override
            public ApiErrorResult call(ServiceResponseWithHeaders<ApiErrorResult, GetKeyRingHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     *
     * @param instanceId Format - uuid. Identifier for the instance
     * @param dataSourceName The name of the datasource that contains the given entity.
     * @param entityName The name of the entity that contains the given key.
     * @param key The value of the alternate key provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApiErrorResult object
     */
    public Observable<ServiceResponseWithHeaders<ApiErrorResult, GetKeyRingHeaders>> getKeyRingWithServiceResponseAsync(String instanceId, String dataSourceName, String entityName, String key) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (dataSourceName == null) {
            throw new IllegalArgumentException("Parameter dataSourceName is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (key == null) {
            throw new IllegalArgumentException("Parameter key is required and cannot be null.");
        }
        return service.getKeyRing(instanceId, dataSourceName, entityName, key)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ApiErrorResult, GetKeyRingHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ApiErrorResult, GetKeyRingHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ApiErrorResult, GetKeyRingHeaders> clientResponse = getKeyRingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ApiErrorResult, GetKeyRingHeaders> getKeyRingDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApiErrorResult, RestException>newInstance(this.serializerAdapter())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetKeyRingHeaders.class);
    }

    /**
     * Gets the profile store state infoformation.
     * Gets the profile store state infoformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getProfileStoreState(String instanceId) {
        return getProfileStoreStateWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Gets the profile store state infoformation.
     * Gets the profile store state infoformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getProfileStoreStateAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getProfileStoreStateWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Gets the profile store state infoformation.
     * Gets the profile store state infoformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getProfileStoreStateAsync(String instanceId) {
        return getProfileStoreStateWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the profile store state infoformation.
     * Gets the profile store state infoformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders>> getProfileStoreStateWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getProfileStoreState(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders> clientResponse = getProfileStoreStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders> getProfileStoreStateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ProfileStoreStateInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetProfileStoreStateHeaders.class);
    }

    /**
     * Get all role definitions.
     * Get all role definitions.
     *
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RoleDefinition&gt; object if successful.
     */
    public List<RoleDefinition> getAllRoleDefinitions(String instanceId) {
        return getAllRoleDefinitionsWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Get all role definitions.
     * Get all role definitions.
     *
     * @param instanceId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RoleDefinition>> getAllRoleDefinitionsAsync(String instanceId, final ServiceCallback<List<RoleDefinition>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllRoleDefinitionsWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Get all role definitions.
     * Get all role definitions.
     *
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleDefinition&gt; object
     */
    public Observable<List<RoleDefinition>> getAllRoleDefinitionsAsync(String instanceId) {
        return getAllRoleDefinitionsWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders>, List<RoleDefinition>>() {
            @Override
            public List<RoleDefinition> call(ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all role definitions.
     * Get all role definitions.
     *
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleDefinition&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders>> getAllRoleDefinitionsWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllRoleDefinitions(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders> clientResponse = getAllRoleDefinitionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders> getAllRoleDefinitionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RoleDefinition>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RoleDefinition>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllRoleDefinitionsHeaders.class);
    }

    /**
     * Get role of current user.
     * Get role of current user.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RoleAssignment object if successful.
     */
    public RoleAssignment getCurrentUserRole(String instanceId) {
        return getCurrentUserRoleWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Get role of current user.
     * Get role of current user.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RoleAssignment> getCurrentUserRoleAsync(String instanceId, final ServiceCallback<RoleAssignment> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getCurrentUserRoleWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Get role of current user.
     * Get role of current user.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RoleAssignment object
     */
    public Observable<RoleAssignment> getCurrentUserRoleAsync(String instanceId) {
        return getCurrentUserRoleWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders>, RoleAssignment>() {
            @Override
            public RoleAssignment call(ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Get role of current user.
     * Get role of current user.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RoleAssignment object
     */
    public Observable<ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders>> getCurrentUserRoleWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getCurrentUserRole(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders> clientResponse = getCurrentUserRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders> getCurrentUserRoleDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RoleAssignment, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RoleAssignment>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetCurrentUserRoleHeaders.class);
    }

    /**
     * Adds or updates a role assignment for a principal.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RoleAssignment&gt; object if successful.
     */
    public List<RoleAssignment> updateARoleAssignment(String instanceId, String principalId) {
        return updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId).toBlocking().single().body();
    }

    /**
     * Adds or updates a role assignment for a principal.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RoleAssignment>> updateARoleAssignmentAsync(String instanceId, String principalId, final ServiceCallback<List<RoleAssignment>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId), serviceCallback);
    }

    /**
     * Adds or updates a role assignment for a principal.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<List<RoleAssignment>> updateARoleAssignmentAsync(String instanceId, String principalId) {
        return updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId).map(new Func1<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>, List<RoleAssignment>>() {
            @Override
            public List<RoleAssignment> call(ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds or updates a role assignment for a principal.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>> updateARoleAssignmentWithServiceResponseAsync(String instanceId, String principalId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (principalId == null) {
            throw new IllegalArgumentException("Parameter principalId is required and cannot be null.");
        }
        final RoleAssignment body = null;
        return service.updateARoleAssignment(instanceId, principalId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> clientResponse = updateARoleAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Adds or updates a role assignment for a principal.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param body The role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RoleAssignment&gt; object if successful.
     */
    public List<RoleAssignment> updateARoleAssignment(String instanceId, String principalId, RoleAssignment body) {
        return updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId, body).toBlocking().single().body();
    }

    /**
     * Adds or updates a role assignment for a principal.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param body The role assignment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RoleAssignment>> updateARoleAssignmentAsync(String instanceId, String principalId, RoleAssignment body, final ServiceCallback<List<RoleAssignment>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId, body), serviceCallback);
    }

    /**
     * Adds or updates a role assignment for a principal.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param body The role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<List<RoleAssignment>> updateARoleAssignmentAsync(String instanceId, String principalId, RoleAssignment body) {
        return updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId, body).map(new Func1<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>, List<RoleAssignment>>() {
            @Override
            public List<RoleAssignment> call(ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds or updates a role assignment for a principal.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param body The role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>> updateARoleAssignmentWithServiceResponseAsync(String instanceId, String principalId, RoleAssignment body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (principalId == null) {
            throw new IllegalArgumentException("Parameter principalId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateARoleAssignment(instanceId, principalId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> clientResponse = updateARoleAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> updateARoleAssignmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RoleAssignment>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RoleAssignment>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateARoleAssignmentHeaders.class);
    }

    /**
     * Deletes a role assignment for the principal.
     * Deletes a role assignment for the principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletesARoleAssignment(String instanceId, String principalId) {
        deletesARoleAssignmentWithServiceResponseAsync(instanceId, principalId).toBlocking().single().body();
    }

    /**
     * Deletes a role assignment for the principal.
     * Deletes a role assignment for the principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletesARoleAssignmentAsync(String instanceId, String principalId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deletesARoleAssignmentWithServiceResponseAsync(instanceId, principalId), serviceCallback);
    }

    /**
     * Deletes a role assignment for the principal.
     * Deletes a role assignment for the principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> deletesARoleAssignmentAsync(String instanceId, String principalId) {
        return deletesARoleAssignmentWithServiceResponseAsync(instanceId, principalId).map(new Func1<ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a role assignment for the principal.
     * Deletes a role assignment for the principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders>> deletesARoleAssignmentWithServiceResponseAsync(String instanceId, String principalId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (principalId == null) {
            throw new IllegalArgumentException("Parameter principalId is required and cannot be null.");
        }
        return service.deletesARoleAssignment(instanceId, principalId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders> clientResponse = deletesARoleAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders> deletesARoleAssignmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeletesARoleAssignmentHeaders.class);
    }

    /**
     * Gets all role assignments for the instance.
     * Gets all role assignments for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RoleAssignment&gt; object if successful.
     */
    public List<RoleAssignment> getAllRoleAssignments(String instanceId) {
        return getAllRoleAssignmentsWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Gets all role assignments for the instance.
     * Gets all role assignments for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RoleAssignment>> getAllRoleAssignmentsAsync(String instanceId, final ServiceCallback<List<RoleAssignment>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllRoleAssignmentsWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Gets all role assignments for the instance.
     * Gets all role assignments for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<List<RoleAssignment>> getAllRoleAssignmentsAsync(String instanceId) {
        return getAllRoleAssignmentsWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders>, List<RoleAssignment>>() {
            @Override
            public List<RoleAssignment> call(ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all role assignments for the instance.
     * Gets all role assignments for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders>> getAllRoleAssignmentsWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllRoleAssignments(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders> clientResponse = getAllRoleAssignmentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders> getAllRoleAssignmentsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RoleAssignment>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RoleAssignment>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllRoleAssignmentsHeaders.class);
    }

    /**
     * Gets all relationship metadata for the provided instanceId.
     * Gets all relationship metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllRelationships(String instanceId) {
        return getAllRelationshipsWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Gets all relationship metadata for the provided instanceId.
     * Gets all relationship metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllRelationshipsAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllRelationshipsWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Gets all relationship metadata for the provided instanceId.
     * Gets all relationship metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllRelationshipsAsync(String instanceId) {
        return getAllRelationshipsWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all relationship metadata for the provided instanceId.
     * Gets all relationship metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders>> getAllRelationshipsWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllRelationships(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders> clientResponse = getAllRelationshipsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders> getAllRelationshipsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RelationshipMetadata>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetAllRelationshipsHeaders.class);
    }

    /**
     * Creates new relationship metadata for the provided instanceId, using input.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createARelationship(String instanceId) {
        return createARelationshipWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Creates new relationship metadata for the provided instanceId, using input.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createARelationshipAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createARelationshipWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Creates new relationship metadata for the provided instanceId, using input.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createARelationshipAsync(String instanceId) {
        return createARelationshipWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates new relationship metadata for the provided instanceId, using input.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>> createARelationshipWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final RelationshipMetadata body = null;
        return service.createARelationship(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> clientResponse = createARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates new relationship metadata for the provided instanceId, using input.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createARelationship(String instanceId, RelationshipMetadata body) {
        return createARelationshipWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * Creates new relationship metadata for the provided instanceId, using input.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body The updated relationship metadata
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createARelationshipAsync(String instanceId, RelationshipMetadata body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createARelationshipWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * Creates new relationship metadata for the provided instanceId, using input.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createARelationshipAsync(String instanceId, RelationshipMetadata body) {
        return createARelationshipWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates new relationship metadata for the provided instanceId, using input.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>> createARelationshipWithServiceResponseAsync(String instanceId, RelationshipMetadata body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createARelationship(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> clientResponse = createARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> createARelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RelationshipMetadata>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, CreateARelationshipHeaders.class);
    }

    /**
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getARelationship(String instanceId, String relationshipName) {
        return getARelationshipWithServiceResponseAsync(instanceId, relationshipName).toBlocking().single().body();
    }

    /**
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getARelationshipAsync(String instanceId, String relationshipName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getARelationshipWithServiceResponseAsync(instanceId, relationshipName), serviceCallback);
    }

    /**
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getARelationshipAsync(String instanceId, String relationshipName) {
        return getARelationshipWithServiceResponseAsync(instanceId, relationshipName).map(new Func1<ServiceResponseWithHeaders<Object, GetARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetARelationshipHeaders>> getARelationshipWithServiceResponseAsync(String instanceId, String relationshipName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relationshipName == null) {
            throw new IllegalArgumentException("Parameter relationshipName is required and cannot be null.");
        }
        return service.getARelationship(instanceId, relationshipName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetARelationshipHeaders> clientResponse = getARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetARelationshipHeaders> getARelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RelationshipMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetARelationshipHeaders.class);
    }

    /**
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteARelationship(String instanceId, String relationshipName) {
        return deleteARelationshipWithServiceResponseAsync(instanceId, relationshipName).toBlocking().single().body();
    }

    /**
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteARelationshipAsync(String instanceId, String relationshipName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteARelationshipWithServiceResponseAsync(instanceId, relationshipName), serviceCallback);
    }

    /**
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteARelationshipAsync(String instanceId, String relationshipName) {
        return deleteARelationshipWithServiceResponseAsync(instanceId, relationshipName).map(new Func1<ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders>> deleteARelationshipWithServiceResponseAsync(String instanceId, String relationshipName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relationshipName == null) {
            throw new IllegalArgumentException("Parameter relationshipName is required and cannot be null.");
        }
        return service.deleteARelationship(instanceId, relationshipName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders> clientResponse = deleteARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders> deleteARelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeletionResponse>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, DeleteARelationshipHeaders.class);
    }

    /**
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateARelationship(String instanceId, String relationshipName) {
        return updateARelationshipWithServiceResponseAsync(instanceId, relationshipName).toBlocking().single().body();
    }

    /**
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateARelationshipAsync(String instanceId, String relationshipName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateARelationshipWithServiceResponseAsync(instanceId, relationshipName), serviceCallback);
    }

    /**
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateARelationshipAsync(String instanceId, String relationshipName) {
        return updateARelationshipWithServiceResponseAsync(instanceId, relationshipName).map(new Func1<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>> updateARelationshipWithServiceResponseAsync(String instanceId, String relationshipName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relationshipName == null) {
            throw new IllegalArgumentException("Parameter relationshipName is required and cannot be null.");
        }
        final RelationshipMetadata body = null;
        return service.updateARelationship(instanceId, relationshipName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> clientResponse = updateARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateARelationship(String instanceId, String relationshipName, RelationshipMetadata body) {
        return updateARelationshipWithServiceResponseAsync(instanceId, relationshipName, body).toBlocking().single().body();
    }

    /**
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param body The updated relationship metadata
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateARelationshipAsync(String instanceId, String relationshipName, RelationshipMetadata body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateARelationshipWithServiceResponseAsync(instanceId, relationshipName, body), serviceCallback);
    }

    /**
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateARelationshipAsync(String instanceId, String relationshipName, RelationshipMetadata body) {
        return updateARelationshipWithServiceResponseAsync(instanceId, relationshipName, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>> updateARelationshipWithServiceResponseAsync(String instanceId, String relationshipName, RelationshipMetadata body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relationshipName == null) {
            throw new IllegalArgumentException("Parameter relationshipName is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateARelationship(instanceId, relationshipName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> clientResponse = updateARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> updateARelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RelationshipMetadata>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, UpdateARelationshipHeaders.class);
    }

    /**
     * Gets the search configuration for the instance.
     * Gets the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSearchConfiguration(String instanceId) {
        return getSearchConfigurationWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Gets the search configuration for the instance.
     * Gets the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSearchConfigurationAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSearchConfigurationWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Gets the search configuration for the instance.
     * Gets the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSearchConfigurationAsync(String instanceId) {
        return getSearchConfigurationWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the search configuration for the instance.
     * Gets the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders>> getSearchConfigurationWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getSearchConfiguration(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders> clientResponse = getSearchConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders> getSearchConfigurationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceSearchConfiguration>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetSearchConfigurationHeaders.class);
    }

    /**
     * Updates the search configuration for the instance.
     * Updates the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateSearchConfiguration(String instanceId) {
        return updateSearchConfigurationWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Updates the search configuration for the instance.
     * Updates the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateSearchConfigurationAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateSearchConfigurationWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Updates the search configuration for the instance.
     * Updates the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateSearchConfigurationAsync(String instanceId) {
        return updateSearchConfigurationWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the search configuration for the instance.
     * Updates the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>> updateSearchConfigurationWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final InstanceSearchConfiguration body = null;
        return service.updateSearchConfiguration(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> clientResponse = updateSearchConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates the search configuration for the instance.
     * Updates the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param body The search configuration for the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateSearchConfiguration(String instanceId, InstanceSearchConfiguration body) {
        return updateSearchConfigurationWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * Updates the search configuration for the instance.
     * Updates the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param body The search configuration for the instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateSearchConfigurationAsync(String instanceId, InstanceSearchConfiguration body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateSearchConfigurationWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * Updates the search configuration for the instance.
     * Updates the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param body The search configuration for the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateSearchConfigurationAsync(String instanceId, InstanceSearchConfiguration body) {
        return updateSearchConfigurationWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the search configuration for the instance.
     * Updates the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param body The search configuration for the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>> updateSearchConfigurationWithServiceResponseAsync(String instanceId, InstanceSearchConfiguration body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateSearchConfiguration(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> clientResponse = updateSearchConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> updateSearchConfigurationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceSearchConfiguration>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, UpdateSearchConfigurationHeaders.class);
    }

    /**
     * Retrieves a list of segment metadata for the provided instanceId.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllSegments(String instanceId) {
        return getAllSegmentsWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Retrieves a list of segment metadata for the provided instanceId.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllSegmentsAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllSegmentsWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Retrieves a list of segment metadata for the provided instanceId.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllSegmentsAsync(String instanceId) {
        return getAllSegmentsWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a list of segment metadata for the provided instanceId.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>> getAllSegmentsWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final Boolean includeHistoricStats = null;
        final Integer historicStatsDays = null;
        return service.getAllSegments(instanceId, includeHistoricStats, historicStatsDays)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> clientResponse = getAllSegmentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves a list of segment metadata for the provided instanceId.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param includeHistoricStats Optional parameter to retrieve evaluation history of all the sgements in instanceId.
     * @param historicStatsDays Format - int32. Optional parameter to get number of days evaluation history.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllSegments(String instanceId, Boolean includeHistoricStats, Integer historicStatsDays) {
        return getAllSegmentsWithServiceResponseAsync(instanceId, includeHistoricStats, historicStatsDays).toBlocking().single().body();
    }

    /**
     * Retrieves a list of segment metadata for the provided instanceId.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param includeHistoricStats Optional parameter to retrieve evaluation history of all the sgements in instanceId.
     * @param historicStatsDays Format - int32. Optional parameter to get number of days evaluation history.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllSegmentsAsync(String instanceId, Boolean includeHistoricStats, Integer historicStatsDays, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllSegmentsWithServiceResponseAsync(instanceId, includeHistoricStats, historicStatsDays), serviceCallback);
    }

    /**
     * Retrieves a list of segment metadata for the provided instanceId.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param includeHistoricStats Optional parameter to retrieve evaluation history of all the sgements in instanceId.
     * @param historicStatsDays Format - int32. Optional parameter to get number of days evaluation history.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllSegmentsAsync(String instanceId, Boolean includeHistoricStats, Integer historicStatsDays) {
        return getAllSegmentsWithServiceResponseAsync(instanceId, includeHistoricStats, historicStatsDays).map(new Func1<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a list of segment metadata for the provided instanceId.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param includeHistoricStats Optional parameter to retrieve evaluation history of all the sgements in instanceId.
     * @param historicStatsDays Format - int32. Optional parameter to get number of days evaluation history.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>> getAllSegmentsWithServiceResponseAsync(String instanceId, Boolean includeHistoricStats, Integer historicStatsDays) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllSegments(instanceId, includeHistoricStats, historicStatsDays)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> clientResponse = getAllSegmentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> getAllSegmentsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<SegmentMetadata>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllSegmentsHeaders.class);
    }

    /**
     * Create new segment metadata with segmentMetadata on instanceId.
     * Create new segment metadata with segmentMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createASegment(String instanceId) {
        return createASegmentWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * Create new segment metadata with segmentMetadata on instanceId.
     * Create new segment metadata with segmentMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createASegmentAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createASegmentWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * Create new segment metadata with segmentMetadata on instanceId.
     * Create new segment metadata with segmentMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createASegmentAsync(String instanceId) {
        return createASegmentWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateASegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create new segment metadata with segmentMetadata on instanceId.
     * Create new segment metadata with segmentMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>> createASegmentWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final SegmentMetadata body = null;
        return service.createASegment(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateASegmentHeaders> clientResponse = createASegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create new segment metadata with segmentMetadata on instanceId.
     * Create new segment metadata with segmentMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Segment metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createASegment(String instanceId, SegmentMetadata body) {
        return createASegmentWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * Create new segment metadata with segmentMetadata on instanceId.
     * Create new segment metadata with segmentMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Segment metadata to be created
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createASegmentAsync(String instanceId, SegmentMetadata body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createASegmentWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * Create new segment metadata with segmentMetadata on instanceId.
     * Create new segment metadata with segmentMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Segment metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createASegmentAsync(String instanceId, SegmentMetadata body) {
        return createASegmentWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateASegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create new segment metadata with segmentMetadata on instanceId.
     * Create new segment metadata with segmentMetadata on instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Segment metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>> createASegmentWithServiceResponseAsync(String instanceId, SegmentMetadata body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createASegment(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateASegmentHeaders> clientResponse = createASegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateASegmentHeaders> createASegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<SegmentMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateASegmentHeaders.class);
    }

    /**
     * Activate segment on instanceId with segmentName.
     * Activate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object activateSegment(String instanceId, String segmentName) {
        return activateSegmentWithServiceResponseAsync(instanceId, segmentName).toBlocking().single().body();
    }

    /**
     * Activate segment on instanceId with segmentName.
     * Activate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> activateSegmentAsync(String instanceId, String segmentName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(activateSegmentWithServiceResponseAsync(instanceId, segmentName), serviceCallback);
    }

    /**
     * Activate segment on instanceId with segmentName.
     * Activate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> activateSegmentAsync(String instanceId, String segmentName) {
        return activateSegmentWithServiceResponseAsync(instanceId, segmentName).map(new Func1<ServiceResponseWithHeaders<Object, ActivateSegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, ActivateSegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Activate segment on instanceId with segmentName.
     * Activate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, ActivateSegmentHeaders>> activateSegmentWithServiceResponseAsync(String instanceId, String segmentName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        return service.activateSegment(instanceId, segmentName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, ActivateSegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, ActivateSegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, ActivateSegmentHeaders> clientResponse = activateSegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, ActivateSegmentHeaders> activateSegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ActivateSegmentHeaders.class);
    }

    /**
     * Deactivate segment on instanceId with segmentName.
     * Deactivate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deactivateSegment(String instanceId, String segmentName) {
        return deactivateSegmentWithServiceResponseAsync(instanceId, segmentName).toBlocking().single().body();
    }

    /**
     * Deactivate segment on instanceId with segmentName.
     * Deactivate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deactivateSegmentAsync(String instanceId, String segmentName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deactivateSegmentWithServiceResponseAsync(instanceId, segmentName), serviceCallback);
    }

    /**
     * Deactivate segment on instanceId with segmentName.
     * Deactivate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deactivateSegmentAsync(String instanceId, String segmentName) {
        return deactivateSegmentWithServiceResponseAsync(instanceId, segmentName).map(new Func1<ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivate segment on instanceId with segmentName.
     * Deactivate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders>> deactivateSegmentWithServiceResponseAsync(String instanceId, String segmentName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        return service.deactivateSegment(instanceId, segmentName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders> clientResponse = deactivateSegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders> deactivateSegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeactivateSegmentHeaders.class);
    }

    /**
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateASegment(String instanceId, String segmentName) {
        return updateASegmentWithServiceResponseAsync(instanceId, segmentName).toBlocking().single().body();
    }

    /**
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateASegmentAsync(String instanceId, String segmentName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateASegmentWithServiceResponseAsync(instanceId, segmentName), serviceCallback);
    }

    /**
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateASegmentAsync(String instanceId, String segmentName) {
        return updateASegmentWithServiceResponseAsync(instanceId, segmentName).map(new Func1<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>> updateASegmentWithServiceResponseAsync(String instanceId, String segmentName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        final SegmentMetadata body = null;
        return service.updateASegment(instanceId, segmentName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> clientResponse = updateASegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param body New Segment metadata to be updated
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateASegment(String instanceId, String segmentName, SegmentMetadata body) {
        return updateASegmentWithServiceResponseAsync(instanceId, segmentName, body).toBlocking().single().body();
    }

    /**
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param body New Segment metadata to be updated
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateASegmentAsync(String instanceId, String segmentName, SegmentMetadata body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateASegmentWithServiceResponseAsync(instanceId, segmentName, body), serviceCallback);
    }

    /**
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param body New Segment metadata to be updated
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateASegmentAsync(String instanceId, String segmentName, SegmentMetadata body) {
        return updateASegmentWithServiceResponseAsync(instanceId, segmentName, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param body New Segment metadata to be updated
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>> updateASegmentWithServiceResponseAsync(String instanceId, String segmentName, SegmentMetadata body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateASegment(instanceId, segmentName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> clientResponse = updateASegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> updateASegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SegmentMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateASegmentHeaders.class);
    }

    /**
     * Deletes the segment metadata for the provided instanceId and segmentName.
     * Deletes the segment metadata for the provided instanceId and segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeletionResponse object if successful.
     */
    public DeletionResponse deleteSegment(String instanceId, String segmentName) {
        return deleteSegmentWithServiceResponseAsync(instanceId, segmentName).toBlocking().single().body();
    }

    /**
     * Deletes the segment metadata for the provided instanceId and segmentName.
     * Deletes the segment metadata for the provided instanceId and segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeletionResponse> deleteSegmentAsync(String instanceId, String segmentName, final ServiceCallback<DeletionResponse> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteSegmentWithServiceResponseAsync(instanceId, segmentName), serviceCallback);
    }

    /**
     * Deletes the segment metadata for the provided instanceId and segmentName.
     * Deletes the segment metadata for the provided instanceId and segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeletionResponse object
     */
    public Observable<DeletionResponse> deleteSegmentAsync(String instanceId, String segmentName) {
        return deleteSegmentWithServiceResponseAsync(instanceId, segmentName).map(new Func1<ServiceResponseWithHeaders<DeletionResponse, DeleteSegmentHeaders>, DeletionResponse>() {
            @Override
            public DeletionResponse call(ServiceResponseWithHeaders<DeletionResponse, DeleteSegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the segment metadata for the provided instanceId and segmentName.
     * Deletes the segment metadata for the provided instanceId and segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeletionResponse object
     */
    public Observable<ServiceResponseWithHeaders<DeletionResponse, DeleteSegmentHeaders>> deleteSegmentWithServiceResponseAsync(String instanceId, String segmentName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        return service.deleteSegment(instanceId, segmentName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<DeletionResponse, DeleteSegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<DeletionResponse, DeleteSegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<DeletionResponse, DeleteSegmentHeaders> clientResponse = deleteSegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<DeletionResponse, DeleteSegmentHeaders> deleteSegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeletionResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeletionResponse>() { }.getType())
                .register(400, new TypeToken<DeletionResponse>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeleteSegmentHeaders.class);
    }

    /**
     * Retrieve information about a workflow job. (Preview).
     * Retrieve information about a workflow job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAWorkflowJobInformation(String instanceId, String workflowName, String jobId) {
        return getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId).toBlocking().single().body();
    }

    /**
     * Retrieve information about a workflow job. (Preview).
     * Retrieve information about a workflow job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAWorkflowJobInformationAsync(String instanceId, String workflowName, String jobId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId), serviceCallback);
    }

    /**
     * Retrieve information about a workflow job. (Preview).
     * Retrieve information about a workflow job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAWorkflowJobInformationAsync(String instanceId, String workflowName, String jobId) {
        return getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId).map(new Func1<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve information about a workflow job. (Preview).
     * Retrieve information about a workflow job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>> getAWorkflowJobInformationWithServiceResponseAsync(String instanceId, String workflowName, String jobId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        if (jobId == null) {
            throw new IllegalArgumentException("Parameter jobId is required and cannot be null.");
        }
        final Boolean includeTasks = null;
        return service.getAWorkflowJobInformation(instanceId, workflowName, jobId, includeTasks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> clientResponse = getAWorkflowJobInformationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieve information about a workflow job. (Preview).
     * Retrieve information about a workflow job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAWorkflowJobInformation(String instanceId, String workflowName, String jobId, Boolean includeTasks) {
        return getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId, includeTasks).toBlocking().single().body();
    }

    /**
     * Retrieve information about a workflow job. (Preview).
     * Retrieve information about a workflow job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param includeTasks Flag to include tasks or not.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAWorkflowJobInformationAsync(String instanceId, String workflowName, String jobId, Boolean includeTasks, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId, includeTasks), serviceCallback);
    }

    /**
     * Retrieve information about a workflow job. (Preview).
     * Retrieve information about a workflow job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAWorkflowJobInformationAsync(String instanceId, String workflowName, String jobId, Boolean includeTasks) {
        return getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId, includeTasks).map(new Func1<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve information about a workflow job. (Preview).
     * Retrieve information about a workflow job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>> getAWorkflowJobInformationWithServiceResponseAsync(String instanceId, String workflowName, String jobId, Boolean includeTasks) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        if (jobId == null) {
            throw new IllegalArgumentException("Parameter jobId is required and cannot be null.");
        }
        return service.getAWorkflowJobInformation(instanceId, workflowName, jobId, includeTasks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> clientResponse = getAWorkflowJobInformationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> getAWorkflowJobInformationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GraphJobInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAWorkflowJobInformationHeaders.class);
    }

    /**
     * Cancel a job. (Preview).
     * Cancel a job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object cancelAWorkflowJob(String instanceId, String workflowName, String jobId) {
        return cancelAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, jobId).toBlocking().single().body();
    }

    /**
     * Cancel a job. (Preview).
     * Cancel a job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> cancelAWorkflowJobAsync(String instanceId, String workflowName, String jobId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(cancelAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, jobId), serviceCallback);
    }

    /**
     * Cancel a job. (Preview).
     * Cancel a job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> cancelAWorkflowJobAsync(String instanceId, String workflowName, String jobId) {
        return cancelAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, jobId).map(new Func1<ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancel a job. (Preview).
     * Cancel a job. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders>> cancelAWorkflowJobWithServiceResponseAsync(String instanceId, String workflowName, String jobId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        if (jobId == null) {
            throw new IllegalArgumentException("Parameter jobId is required and cannot be null.");
        }
        return service.cancelAWorkflowJob(instanceId, workflowName, jobId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders> clientResponse = cancelAWorkflowJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders> cancelAWorkflowJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GraphJobInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CancelAWorkflowJobHeaders.class);
    }

    /**
     * Retrieves a list of recent job information. (Preview).
     * Retrieves a list of recent job information. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getListOfRecentWorkflowJobs(String instanceId, String workflowName) {
        return getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * Retrieves a list of recent job information. (Preview).
     * Retrieves a list of recent job information. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getListOfRecentWorkflowJobsAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * Retrieves a list of recent job information. (Preview).
     * Retrieves a list of recent job information. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getListOfRecentWorkflowJobsAsync(String instanceId, String workflowName) {
        return getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a list of recent job information. (Preview).
     * Retrieves a list of recent job information. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>> getListOfRecentWorkflowJobsWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        final Integer top = null;
        final Boolean includeTasks = null;
        return service.getListOfRecentWorkflowJobs(instanceId, workflowName, top, includeTasks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> clientResponse = getListOfRecentWorkflowJobsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves a list of recent job information. (Preview).
     * Retrieves a list of recent job information. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of job informations to retrieve.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getListOfRecentWorkflowJobs(String instanceId, String workflowName, Integer top, Boolean includeTasks) {
        return getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName, top, includeTasks).toBlocking().single().body();
    }

    /**
     * Retrieves a list of recent job information. (Preview).
     * Retrieves a list of recent job information. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of job informations to retrieve.
     * @param includeTasks Flag to include tasks or not.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getListOfRecentWorkflowJobsAsync(String instanceId, String workflowName, Integer top, Boolean includeTasks, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName, top, includeTasks), serviceCallback);
    }

    /**
     * Retrieves a list of recent job information. (Preview).
     * Retrieves a list of recent job information. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of job informations to retrieve.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getListOfRecentWorkflowJobsAsync(String instanceId, String workflowName, Integer top, Boolean includeTasks) {
        return getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName, top, includeTasks).map(new Func1<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a list of recent job information. (Preview).
     * Retrieves a list of recent job information. (Preview).
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of job informations to retrieve.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>> getListOfRecentWorkflowJobsWithServiceResponseAsync(String instanceId, String workflowName, Integer top, Boolean includeTasks) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        return service.getListOfRecentWorkflowJobs(instanceId, workflowName, top, includeTasks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> clientResponse = getListOfRecentWorkflowJobsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> getListOfRecentWorkflowJobsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GraphJobInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetListOfRecentWorkflowJobsHeaders.class);
    }

    /**
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object submitAWorkflowJob(String instanceId, String workflowName) {
        return submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> submitAWorkflowJobAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> submitAWorkflowJobAsync(String instanceId, String workflowName) {
        return submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>> submitAWorkflowJobWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        final OnDemandJobRequest body = null;
        final String operationType = null;
        final List<String> identifiers = null;
        final Boolean forceRunRequested = null;
        String identifiersConverted = this.serializerAdapter().serializeList(identifiers, CollectionFormat.CSV);
        return service.submitAWorkflowJob(instanceId, workflowName, body, operationType, identifiersConverted, forceRunRequested)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> clientResponse = submitAWorkflowJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param body Job Creation Request.
     * @param operationType The workflow operation type.
     * @param identifiers A list of workflow identifiers.
     * @param forceRunRequested Whether to request a force run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object submitAWorkflowJob(String instanceId, String workflowName, OnDemandJobRequest body, String operationType, List<String> identifiers, Boolean forceRunRequested) {
        return submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, body, operationType, identifiers, forceRunRequested).toBlocking().single().body();
    }

    /**
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param body Job Creation Request.
     * @param operationType The workflow operation type.
     * @param identifiers A list of workflow identifiers.
     * @param forceRunRequested Whether to request a force run.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> submitAWorkflowJobAsync(String instanceId, String workflowName, OnDemandJobRequest body, String operationType, List<String> identifiers, Boolean forceRunRequested, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, body, operationType, identifiers, forceRunRequested), serviceCallback);
    }

    /**
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param body Job Creation Request.
     * @param operationType The workflow operation type.
     * @param identifiers A list of workflow identifiers.
     * @param forceRunRequested Whether to request a force run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> submitAWorkflowJobAsync(String instanceId, String workflowName, OnDemandJobRequest body, String operationType, List<String> identifiers, Boolean forceRunRequested) {
        return submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, body, operationType, identifiers, forceRunRequested).map(new Func1<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run. (Preview).
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param body Job Creation Request.
     * @param operationType The workflow operation type.
     * @param identifiers A list of workflow identifiers.
     * @param forceRunRequested Whether to request a force run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>> submitAWorkflowJobWithServiceResponseAsync(String instanceId, String workflowName, OnDemandJobRequest body, String operationType, List<String> identifiers, Boolean forceRunRequested) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        Validator.validate(body);
        Validator.validate(identifiers);
        String identifiersConverted = this.serializerAdapter().serializeList(identifiers, CollectionFormat.CSV);
        return service.submitAWorkflowJob(instanceId, workflowName, body, operationType, identifiersConverted, forceRunRequested)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> clientResponse = submitAWorkflowJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> submitAWorkflowJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GraphJobInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, SubmitAWorkflowJobHeaders.class);
    }

    /**
     * Retrieves a list of historic task information for a workflow.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getListOfWorkflowTaskInformationHistory(String instanceId, String workflowName) {
        return getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * Retrieves a list of historic task information for a workflow.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getListOfWorkflowTaskInformationHistoryAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * Retrieves a list of historic task information for a workflow.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getListOfWorkflowTaskInformationHistoryAsync(String instanceId, String workflowName) {
        return getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a list of historic task information for a workflow.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>> getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        final Integer top = null;
        return service.getListOfWorkflowTaskInformationHistory(instanceId, workflowName, top)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> clientResponse = getListOfWorkflowTaskInformationHistoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves a list of historic task information for a workflow.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of task informations to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getListOfWorkflowTaskInformationHistory(String instanceId, String workflowName, Integer top) {
        return getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName, top).toBlocking().single().body();
    }

    /**
     * Retrieves a list of historic task information for a workflow.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of task informations to retrieve.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getListOfWorkflowTaskInformationHistoryAsync(String instanceId, String workflowName, Integer top, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName, top), serviceCallback);
    }

    /**
     * Retrieves a list of historic task information for a workflow.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of task informations to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getListOfWorkflowTaskInformationHistoryAsync(String instanceId, String workflowName, Integer top) {
        return getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName, top).map(new Func1<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a list of historic task information for a workflow.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of task informations to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>> getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(String instanceId, String workflowName, Integer top) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        return service.getListOfWorkflowTaskInformationHistory(instanceId, workflowName, top)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> clientResponse = getListOfWorkflowTaskInformationHistoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> getListOfWorkflowTaskInformationHistoryDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GraphTaskInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetListOfWorkflowTaskInformationHistoryHeaders.class);
    }

    /**
     * Gets the current status for a workflow.
     * Gets the current status for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getWorkflowStatus(String instanceId, String workflowName) {
        return getWorkflowStatusWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * Gets the current status for a workflow.
     * Gets the current status for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The workflow name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getWorkflowStatusAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWorkflowStatusWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * Gets the current status for a workflow.
     * Gets the current status for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getWorkflowStatusAsync(String instanceId, String workflowName) {
        return getWorkflowStatusWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the current status for a workflow.
     * Gets the current status for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders>> getWorkflowStatusWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        return service.getWorkflowStatus(instanceId, workflowName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders> clientResponse = getWorkflowStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders> getWorkflowStatusDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GraphNodeInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetWorkflowStatusHeaders.class);
    }

    /**
     * Gets a list of supported timezones for creating workflow schedules.
     * Gets a list of supported timezones for creating workflow schedules.
     *
     * @param workflowName Any workflow name.
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedTimezones(String workflowName, String instanceId) {
        return getSupportedTimezonesWithServiceResponseAsync(workflowName, instanceId).toBlocking().single().body();
    }

    /**
     * Gets a list of supported timezones for creating workflow schedules.
     * Gets a list of supported timezones for creating workflow schedules.
     *
     * @param workflowName Any workflow name.
     * @param instanceId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedTimezonesAsync(String workflowName, String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedTimezonesWithServiceResponseAsync(workflowName, instanceId), serviceCallback);
    }

    /**
     * Gets a list of supported timezones for creating workflow schedules.
     * Gets a list of supported timezones for creating workflow schedules.
     *
     * @param workflowName Any workflow name.
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedTimezonesAsync(String workflowName, String instanceId) {
        return getSupportedTimezonesWithServiceResponseAsync(workflowName, instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported timezones for creating workflow schedules.
     * Gets a list of supported timezones for creating workflow schedules.
     *
     * @param workflowName Any workflow name.
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders>> getSupportedTimezonesWithServiceResponseAsync(String workflowName, String instanceId) {
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getSupportedTimezones(workflowName, instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders> clientResponse = getSupportedTimezonesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders> getSupportedTimezonesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<TimezoneDetail>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetSupportedTimezonesHeaders.class);
    }

    /**
     * Gets all workflow refresh schedules.
     * Gets all workflow refresh schedules.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getWorkflowSchedules(String instanceId, String workflowName) {
        return getWorkflowSchedulesWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * Gets all workflow refresh schedules.
     * Gets all workflow refresh schedules.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getWorkflowSchedulesAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWorkflowSchedulesWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * Gets all workflow refresh schedules.
     * Gets all workflow refresh schedules.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getWorkflowSchedulesAsync(String instanceId, String workflowName) {
        return getWorkflowSchedulesWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all workflow refresh schedules.
     * Gets all workflow refresh schedules.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders>> getWorkflowSchedulesWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        return service.getWorkflowSchedules(instanceId, workflowName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders> clientResponse = getWorkflowSchedulesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders> getWorkflowSchedulesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<WorkflowRefreshSchedule>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetWorkflowSchedulesHeaders.class);
    }

    /**
     * Create a workflow refresh schedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createWorkflowRefreshSchedule(String instanceId, String workflowName) {
        return createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * Create a workflow refresh schedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createWorkflowRefreshScheduleAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * Create a workflow refresh schedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createWorkflowRefreshScheduleAsync(String instanceId, String workflowName) {
        return createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a workflow refresh schedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>> createWorkflowRefreshScheduleWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        final WorkflowRefreshSchedule body = null;
        return service.createWorkflowRefreshSchedule(instanceId, workflowName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> clientResponse = createWorkflowRefreshScheduleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create a workflow refresh schedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param body A schedule object to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createWorkflowRefreshSchedule(String instanceId, String workflowName, WorkflowRefreshSchedule body) {
        return createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName, body).toBlocking().single().body();
    }

    /**
     * Create a workflow refresh schedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param body A schedule object to create.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createWorkflowRefreshScheduleAsync(String instanceId, String workflowName, WorkflowRefreshSchedule body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName, body), serviceCallback);
    }

    /**
     * Create a workflow refresh schedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param body A schedule object to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createWorkflowRefreshScheduleAsync(String instanceId, String workflowName, WorkflowRefreshSchedule body) {
        return createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName, body).map(new Func1<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a workflow refresh schedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param body A schedule object to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>> createWorkflowRefreshScheduleWithServiceResponseAsync(String instanceId, String workflowName, WorkflowRefreshSchedule body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createWorkflowRefreshSchedule(instanceId, workflowName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> clientResponse = createWorkflowRefreshScheduleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> createWorkflowRefreshScheduleDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WorkflowRefreshSchedule>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateWorkflowRefreshScheduleHeaders.class);
    }

    /**
     * Gets the entityProfile for the entity.
     * Gets the entityProfile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityDataProfile object if successful.
     */
    public EntityDataProfile getAnEntityProfile(String instanceId, String qualifiedEntityName) {
        return getAnEntityProfileWithServiceResponseAsync(instanceId, qualifiedEntityName).toBlocking().single().body();
    }

    /**
     * Gets the entityProfile for the entity.
     * Gets the entityProfile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityDataProfile> getAnEntityProfileAsync(String instanceId, String qualifiedEntityName, final ServiceCallback<EntityDataProfile> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAnEntityProfileWithServiceResponseAsync(instanceId, qualifiedEntityName), serviceCallback);
    }

    /**
     * Gets the entityProfile for the entity.
     * Gets the entityProfile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityDataProfile object
     */
    public Observable<EntityDataProfile> getAnEntityProfileAsync(String instanceId, String qualifiedEntityName) {
        return getAnEntityProfileWithServiceResponseAsync(instanceId, qualifiedEntityName).map(new Func1<ServiceResponseWithHeaders<EntityDataProfile, GetAnEntityProfileHeaders>, EntityDataProfile>() {
            @Override
            public EntityDataProfile call(ServiceResponseWithHeaders<EntityDataProfile, GetAnEntityProfileHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the entityProfile for the entity.
     * Gets the entityProfile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityDataProfile object
     */
    public Observable<ServiceResponseWithHeaders<EntityDataProfile, GetAnEntityProfileHeaders>> getAnEntityProfileWithServiceResponseAsync(String instanceId, String qualifiedEntityName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (qualifiedEntityName == null) {
            throw new IllegalArgumentException("Parameter qualifiedEntityName is required and cannot be null.");
        }
        return service.getAnEntityProfile(instanceId, qualifiedEntityName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<EntityDataProfile, GetAnEntityProfileHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<EntityDataProfile, GetAnEntityProfileHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<EntityDataProfile, GetAnEntityProfileHeaders> clientResponse = getAnEntityProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<EntityDataProfile, GetAnEntityProfileHeaders> getAnEntityProfileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntityDataProfile, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntityDataProfile>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAnEntityProfileHeaders.class);
    }

}
