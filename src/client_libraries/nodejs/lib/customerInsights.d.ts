/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import { ServiceClient, ServiceClientOptions, ServiceCallback, HttpOperationResponse } from 'ms-rest';
import * as models from "./models";

export default class CustomerInsights extends ServiceClient {
  /**
   * @class
   * Initializes a new instance of the CustomerInsights class.
   * @constructor
   *
   * @param {string} [baseUri] - The base URI of the service.
   *
   * @param {object} [options] - The parameter options
   *
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   *
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   *
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   *
   */
  constructor(baseUri?: string, options?: ServiceClientOptions);


  /**
   * @summary Gets the specific attribute profile for the entity.
   *
   * Gets the specific attribute profile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {string} attributeName Attribute Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AttributeDataProfile>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAnAttributeProfileWithHttpOperationResponse(instanceId: string, qualifiedEntityName: string, attributeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.AttributeDataProfile>>;

  /**
   * @summary Gets the specific attribute profile for the entity.
   *
   * Gets the specific attribute profile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {string} attributeName Attribute Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {AttributeDataProfile} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {AttributeDataProfile} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AttributeDataProfile} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAnAttributeProfile(instanceId: string, qualifiedEntityName: string, attributeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.AttributeDataProfile>;
  getAnAttributeProfile(instanceId: string, qualifiedEntityName: string, attributeName: string, callback: ServiceCallback<models.AttributeDataProfile>): void;
  getAnAttributeProfile(instanceId: string, qualifiedEntityName: string, attributeName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.AttributeDataProfile>): void;


  /**
   * @summary Fetches a collection of DataSourceInfo configured for the Customer
   * Insights instance.
   *
   * Fetches a collection of DataSourceInfo configured for the Customer Insights
   * instance.
   *
   * @param {string} instanceId Format - uuid. The instance id for which to fetch
   * data source info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllDataSourcesWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Fetches a collection of DataSourceInfo configured for the Customer
   * Insights instance.
   *
   * Fetches a collection of DataSourceInfo configured for the Customer Insights
   * instance.
   *
   * @param {string} instanceId Format - uuid. The instance id for which to fetch
   * data source info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllDataSources(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllDataSources(instanceId: string, callback: ServiceCallback<any>): void;
  getAllDataSources(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Fetches a DataSourceInfo matching the dataSourceId configured for
   * the Customer Insights instance.
   *
   * Fetches a DataSourceInfo matching the dataSourceId configured for the
   * Customer Insights instance.
   *
   * @param {string} instanceId Format - uuid. The instance id to fetch data
   * source info for.
   *
   * @param {string} dataSourceId Format - uuid. The data source id to fetch info
   * for.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDataSourceWithHttpOperationResponse(instanceId: string, dataSourceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Fetches a DataSourceInfo matching the dataSourceId configured for
   * the Customer Insights instance.
   *
   * Fetches a DataSourceInfo matching the dataSourceId configured for the
   * Customer Insights instance.
   *
   * @param {string} instanceId Format - uuid. The instance id to fetch data
   * source info for.
   *
   * @param {string} dataSourceId Format - uuid. The data source id to fetch info
   * for.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDataSource(instanceId: string, dataSourceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getDataSource(instanceId: string, dataSourceId: string, callback: ServiceCallback<any>): void;
  getDataSource(instanceId: string, dataSourceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Deletes a data source from the instance.
   *
   * Deletes a data source from the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} dataSourceId Format - uuid. The data source id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteADataSourceWithHttpOperationResponse(instanceId: string, dataSourceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Deletes a data source from the instance.
   *
   * Deletes a data source from the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} dataSourceId Format - uuid. The data source id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteADataSource(instanceId: string, dataSourceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteADataSource(instanceId: string, dataSourceId: string, callback: ServiceCallback<any>): void;
  deleteADataSource(instanceId: string, dataSourceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Writes an entity instance into the store, g. an activity entity.
   * (Preview)
   *
   * Writes an entity instance into the store, g. an activity entity. (Preview)
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, consisting of
   * 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] JSON document representing the entity. The
   * schema must be consistent with the entity metadata. Use GET action of this
   * resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createAnEntityWithHttpOperationResponse(instanceId: string, entityName: string, options?: { body? : any, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Writes an entity instance into the store, g. an activity entity.
   * (Preview)
   *
   * Writes an entity instance into the store, g. an activity entity. (Preview)
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, consisting of
   * 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] JSON document representing the entity. The
   * schema must be consistent with the entity metadata. Use GET action of this
   * resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createAnEntity(instanceId: string, entityName: string, options?: { body? : any, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createAnEntity(instanceId: string, entityName: string, callback: ServiceCallback<any>): void;
  createAnEntity(instanceId: string, entityName: string, options: { body? : any, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Updates an entity instance in the store, g. Customer entity.
   * (Preview)
   *
   * Updates an entity instance in the store, g. Customer entity. (Preview)
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, e.g. 'Customer'.
   *
   * @param {string} entityId Id of the entity to update, e.g. 'CustomerId' of a
   * Customer entity.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] JSON document with set of changes to apply on
   * the entity. Each change must be consistent with the entity metadata. Use GET
   * action of this resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateAnEntityWithHttpOperationResponse(instanceId: string, entityName: string, entityId: string, options?: { body? : any, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Updates an entity instance in the store, g. Customer entity.
   * (Preview)
   *
   * Updates an entity instance in the store, g. Customer entity. (Preview)
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, e.g. 'Customer'.
   *
   * @param {string} entityId Id of the entity to update, e.g. 'CustomerId' of a
   * Customer entity.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] JSON document with set of changes to apply on
   * the entity. Each change must be consistent with the entity metadata. Use GET
   * action of this resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAnEntity(instanceId: string, entityName: string, entityId: string, options?: { body? : any, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateAnEntity(instanceId: string, entityName: string, entityId: string, callback: ServiceCallback<any>): void;
  updateAnEntity(instanceId: string, entityName: string, entityId: string, options: { body? : any, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Submits an OData request to the service.
   *
   * Submits an OData request to the service.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.relativePath] Relative OData path. See
   * https://www.odata.org/getting-started/basic-tutorial/ for info.
   *
   * @param {boolean} [options.forceSearch] Whether force use search to support
   * the query.
   *
   * @param {boolean} [options.proxy] Whether or not we are requesting data by
   * proxy.
   *
   * @param {string} [options.search]
   *
   * @param {string} [options.select]
   *
   * @param {string} [options.skipToken]
   *
   * @param {string} [options.filter]
   *
   * @param {string} [options.orderBy]
   *
   * @param {string} [options.expand]
   *
   * @param {number} [options.top] Format - int32.
   *
   * @param {number} [options.skip] Format - int32.
   *
   * @param {boolean} [options.skipNullFilterParameters]
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getEntitiesWithODataQueryParametersWithHttpOperationResponse(instanceId: string, options?: { relativePath? : string, forceSearch? : boolean, proxy? : boolean, search? : string, select? : string, skipToken? : string, filter? : string, orderBy? : string, expand? : string, top? : number, skip? : number, skipNullFilterParameters? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Submits an OData request to the service.
   *
   * Submits an OData request to the service.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.relativePath] Relative OData path. See
   * https://www.odata.org/getting-started/basic-tutorial/ for info.
   *
   * @param {boolean} [options.forceSearch] Whether force use search to support
   * the query.
   *
   * @param {boolean} [options.proxy] Whether or not we are requesting data by
   * proxy.
   *
   * @param {string} [options.search]
   *
   * @param {string} [options.select]
   *
   * @param {string} [options.skipToken]
   *
   * @param {string} [options.filter]
   *
   * @param {string} [options.orderBy]
   *
   * @param {string} [options.expand]
   *
   * @param {number} [options.top] Format - int32.
   *
   * @param {number} [options.skip] Format - int32.
   *
   * @param {boolean} [options.skipNullFilterParameters]
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitiesWithODataQueryParameters(instanceId: string, options?: { relativePath? : string, forceSearch? : boolean, proxy? : boolean, search? : string, select? : string, skipToken? : string, filter? : string, orderBy? : string, expand? : string, top? : number, skip? : number, skipNullFilterParameters? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getEntitiesWithODataQueryParameters(instanceId: string, callback: ServiceCallback<any>): void;
  getEntitiesWithODataQueryParameters(instanceId: string, options: { relativePath? : string, forceSearch? : boolean, proxy? : boolean, search? : string, select? : string, skipToken? : string, filter? : string, orderBy? : string, expand? : string, top? : number, skip? : number, skipNullFilterParameters? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves the flattened entity model for the provided instanceId.
   *
   * Retrieves the flattened entity model for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {boolean} [options.includeQuarantined] Indicates if quarantined
   * entities should be included in the output entity model.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllEntityMetadataWithHttpOperationResponse(instanceId: string, options?: { attributesAnnotations? : boolean, includeQuarantined? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves the flattened entity model for the provided instanceId.
   *
   * Retrieves the flattened entity model for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {boolean} [options.includeQuarantined] Indicates if quarantined
   * entities should be included in the output entity model.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllEntityMetadata(instanceId: string, options?: { attributesAnnotations? : boolean, includeQuarantined? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllEntityMetadata(instanceId: string, callback: ServiceCallback<any>): void;
  getAllEntityMetadata(instanceId: string, options: { attributesAnnotations? : boolean, includeQuarantined? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves the entity metadata for the provided instanceId and
   * entityName.
   *
   * Retrieves the entity metadata for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getEntityMetadataWithHttpOperationResponse(instanceId: string, entityName: string, options?: { attributesAnnotations? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves the entity metadata for the provided instanceId and
   * entityName.
   *
   * Retrieves the entity metadata for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntityMetadata(instanceId: string, entityName: string, options?: { attributesAnnotations? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getEntityMetadata(instanceId: string, entityName: string, callback: ServiceCallback<any>): void;
  getEntityMetadata(instanceId: string, entityName: string, options: { attributesAnnotations? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves the entity size for the provided instanceId and
   * entityName.
   *
   * Retrieves the entity size for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getEntitySizeWithHttpOperationResponse(instanceId: string, entityName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves the entity size for the provided instanceId and
   * entityName.
   *
   * Retrieves the entity size for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitySize(instanceId: string, entityName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getEntitySize(instanceId: string, entityName: string, callback: ServiceCallback<any>): void;
  getEntitySize(instanceId: string, entityName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Reset scopes in the given instance. Provide optional management
   * operation scope to reset only that scope. (Preview)
   *
   * Reset scopes in the given instance. Provide optional management operation
   * scope to reset only that scope. (Preview)
   *
   * @param {string} instanceId Format - uuid. The instance Id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.instanceManagementOperationScope] The management
   * operation scope for reset.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resetAnInstanceWithHttpOperationResponse(instanceId: string, options?: { instanceManagementOperationScope? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Reset scopes in the given instance. Provide optional management
   * operation scope to reset only that scope. (Preview)
   *
   * Reset scopes in the given instance. Provide optional management operation
   * scope to reset only that scope. (Preview)
   *
   * @param {string} instanceId Format - uuid. The instance Id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.instanceManagementOperationScope] The management
   * operation scope for reset.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resetAnInstance(instanceId: string, options?: { instanceManagementOperationScope? : string, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  resetAnInstance(instanceId: string, callback: ServiceCallback<any>): void;
  resetAnInstance(instanceId: string, options: { instanceManagementOperationScope? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Reset scopes in the given instance. Provide optional management
   * operation scope to reset only that scope. (Preview)
   *
   * Reset scopes in the given instance. Provide optional management operation
   * scope to reset only that scope. (Preview)
   *
   * @param {string} instanceId Format - uuid. The instance Id.
   *
   * @param {string} instanceManagementOperationScope The management operation
   * scope for reset.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resetInstanceForScopeWithHttpOperationResponse(instanceId: string, instanceManagementOperationScope: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Reset scopes in the given instance. Provide optional management
   * operation scope to reset only that scope. (Preview)
   *
   * Reset scopes in the given instance. Provide optional management operation
   * scope to reset only that scope. (Preview)
   *
   * @param {string} instanceId Format - uuid. The instance Id.
   *
   * @param {string} instanceManagementOperationScope The management operation
   * scope for reset.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resetInstanceForScope(instanceId: string, instanceManagementOperationScope: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  resetInstanceForScope(instanceId: string, instanceManagementOperationScope: string, callback: ServiceCallback<any>): void;
  resetInstanceForScope(instanceId: string, instanceManagementOperationScope: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves all instances of the current user.
   *
   * Retrieves all instances of the current user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllInstancesWithHttpOperationResponse(options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves all instances of the current user.
   *
   * Retrieves all instances of the current user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllInstances(options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllInstances(callback: ServiceCallback<any>): void;
  getAllInstances(options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves instances based on instance ids, it can only accept batch
   * of instances.
   *
   * Retrieves instances based on instance ids, it can only accept batch of
   * instances.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.body] Instance ids of instances to get.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllInstancesInBatchesByInstanceidsWithHttpOperationResponse(options?: { body? : string[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves instances based on instance ids, it can only accept batch
   * of instances.
   *
   * Retrieves instances based on instance ids, it can only accept batch of
   * instances.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.body] Instance ids of instances to get.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllInstancesInBatchesByInstanceids(options?: { body? : string[], customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllInstancesInBatchesByInstanceids(callback: ServiceCallback<any>): void;
  getAllInstancesInBatchesByInstanceids(options: { body? : string[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves metadata for a Customer Insights instance based on its
   * instanceId.
   *
   * Retrieves metadata for a Customer Insights instance based on its instanceId.
   *
   * @param {string} instanceId Format - uuid. Unique id for the Customer
   * Insights instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getInstanceMetadataWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves metadata for a Customer Insights instance based on its
   * instanceId.
   *
   * Retrieves metadata for a Customer Insights instance based on its instanceId.
   *
   * @param {string} instanceId Format - uuid. Unique id for the Customer
   * Insights instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getInstanceMetadata(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getInstanceMetadata(instanceId: string, callback: ServiceCallback<any>): void;
  getInstanceMetadata(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Detele an instance.
   *
   * Detele an instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteAnInstanceWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Detele an instance.
   *
   * Detele an instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAnInstance(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteAnInstance(instanceId: string, callback: ServiceCallback<any>): void;
  deleteAnInstance(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Creates a new instance.
   *
   * Creates a new instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The instance creation request.
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {string} [options.body.instanceMetadata.bapEnvironmentId] Gets the Id
   * of the BAP Environment associated with the current instance.
   *
   * @param {string} [options.body.instanceMetadata.ppdfProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'attaching',
   * 'attached', 'installing', 'installed', 'failed'
   *
   * @param {string} [options.body.instanceMetadata.pbiProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'failed'
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * Workspace Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds workspace unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.isTrial] True if the new instance is a trial
   * instance. False otherwise.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createAnInstanceWithHttpOperationResponse(options?: { body? : models.InstanceCreationRequest, isTrial? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Creates a new instance.
   *
   * Creates a new instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The instance creation request.
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {string} [options.body.instanceMetadata.bapEnvironmentId] Gets the Id
   * of the BAP Environment associated with the current instance.
   *
   * @param {string} [options.body.instanceMetadata.ppdfProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'attaching',
   * 'attached', 'installing', 'installed', 'failed'
   *
   * @param {string} [options.body.instanceMetadata.pbiProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'failed'
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * Workspace Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds workspace unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.isTrial] True if the new instance is a trial
   * instance. False otherwise.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createAnInstance(options?: { body? : models.InstanceCreationRequest, isTrial? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createAnInstance(callback: ServiceCallback<any>): void;
  createAnInstance(options: { body? : models.InstanceCreationRequest, isTrial? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Patches the Market Verticals, Display name, Domain Name, CDS
   * environment and BYOSA secret to the instance.
   *
   * Patches the Market Verticals, Display name, Domain Name, CDS environment and
   * BYOSA secret to the instance.
   *
   * @param {string} instanceId Format - uuid.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {string} [options.body.instanceMetadata.bapEnvironmentId] Gets the Id
   * of the BAP Environment associated with the current instance.
   *
   * @param {string} [options.body.instanceMetadata.ppdfProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'attaching',
   * 'attached', 'installing', 'installed', 'failed'
   *
   * @param {string} [options.body.instanceMetadata.pbiProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'failed'
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * Workspace Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds workspace unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateAnInstanceWithHttpOperationResponse(instanceId: string, options?: { body? : models.InstanceCreationRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Patches the Market Verticals, Display name, Domain Name, CDS
   * environment and BYOSA secret to the instance.
   *
   * Patches the Market Verticals, Display name, Domain Name, CDS environment and
   * BYOSA secret to the instance.
   *
   * @param {string} instanceId Format - uuid.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {string} [options.body.instanceMetadata.bapEnvironmentId] Gets the Id
   * of the BAP Environment associated with the current instance.
   *
   * @param {string} [options.body.instanceMetadata.ppdfProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'attaching',
   * 'attached', 'installing', 'installed', 'failed'
   *
   * @param {string} [options.body.instanceMetadata.pbiProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'failed'
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * Workspace Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds workspace unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAnInstance(instanceId: string, options?: { body? : models.InstanceCreationRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateAnInstance(instanceId: string, callback: ServiceCallback<any>): void;
  updateAnInstance(instanceId: string, options: { body? : models.InstanceCreationRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Create a new instance and copy metadata from an existing instance.
   *
   * Create a new instance and copy metadata from an existing instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The metadata to use to create the new
   * instance.
   *
   * @param {uuid} [options.body.instanceIdToCopy]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {string} [options.body.instanceMetadata.bapEnvironmentId] Gets the Id
   * of the BAP Environment associated with the current instance.
   *
   * @param {string} [options.body.instanceMetadata.ppdfProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'attaching',
   * 'attached', 'installing', 'installed', 'failed'
   *
   * @param {string} [options.body.instanceMetadata.pbiProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'failed'
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * Workspace Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds workspace unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.isTrial] True if the new instance is a trial
   * instance. False otherwise.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  copyAnInstanceWithHttpOperationResponse(options?: { body? : models.InstanceCopyRequest, isTrial? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Create a new instance and copy metadata from an existing instance.
   *
   * Create a new instance and copy metadata from an existing instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The metadata to use to create the new
   * instance.
   *
   * @param {uuid} [options.body.instanceIdToCopy]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {string} [options.body.instanceMetadata.bapEnvironmentId] Gets the Id
   * of the BAP Environment associated with the current instance.
   *
   * @param {string} [options.body.instanceMetadata.ppdfProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'attaching',
   * 'attached', 'installing', 'installed', 'failed'
   *
   * @param {string} [options.body.instanceMetadata.pbiProvisionState] Possible
   * values include: 'notStarted', 'creating', 'created', 'failed'
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * Workspace Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds workspace unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds'
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.isTrial] True if the new instance is a trial
   * instance. False otherwise.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  copyAnInstance(options?: { body? : models.InstanceCopyRequest, isTrial? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  copyAnInstance(callback: ServiceCallback<any>): void;
  copyAnInstance(options: { body? : models.InstanceCopyRequest, isTrial? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves a list of measures metadata for the provided instanceId.
   *
   * Retrieves a list of measures metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAListOfMeasuresMetadataWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves a list of measures metadata for the provided instanceId.
   *
   * Retrieves a list of measures metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAListOfMeasuresMetadata(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAListOfMeasuresMetadata(instanceId: string, callback: ServiceCallback<any>): void;
  getAListOfMeasuresMetadata(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Create new measure metadata with measureMetadata on instanceId.
   *
   * Create new measure metadata with measureMetadata on instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Measure metadata to be created
   *
   * @param {string} [options.body.name] Gets the unique name of the measure
   *
   * @param {string} [options.body.description] Gets the description of the
   * measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Gets or sets the
   * evaluation completion time.
   *
   * @param {string} [options.body.latestEvaluation.error] Gets or sets the error
   * (if any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Gets the output folder path for
   * the evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Gets the last
   * successful evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount] Gets
   * the number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Gets the last
   * validation evaluation date
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Gets the evaluation history
   * for the measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Gets the output history for the
   * measure. (not persisted in store)
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createAMeasureWithHttpOperationResponse(instanceId: string, options?: { body? : models.MeasureMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Create new measure metadata with measureMetadata on instanceId.
   *
   * Create new measure metadata with measureMetadata on instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Measure metadata to be created
   *
   * @param {string} [options.body.name] Gets the unique name of the measure
   *
   * @param {string} [options.body.description] Gets the description of the
   * measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Gets or sets the
   * evaluation completion time.
   *
   * @param {string} [options.body.latestEvaluation.error] Gets or sets the error
   * (if any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Gets the output folder path for
   * the evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Gets the last
   * successful evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount] Gets
   * the number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Gets the last
   * validation evaluation date
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Gets the evaluation history
   * for the measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Gets the output history for the
   * measure. (not persisted in store)
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createAMeasure(instanceId: string, options?: { body? : models.MeasureMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createAMeasure(instanceId: string, callback: ServiceCallback<any>): void;
  createAMeasure(instanceId: string, options: { body? : models.MeasureMetadata, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves the measure metadata for the provided instanceId and
   * measureName.
   *
   * Retrieves the measure metadata for the provided instanceId and measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Boolean for historical stats
   *
   * @param {number} [options.historicStatsDays] Format - int32. Number of
   * lookback days
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getMetadataForAMeasureWithHttpOperationResponse(instanceId: string, measureName: string, options?: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves the measure metadata for the provided instanceId and
   * measureName.
   *
   * Retrieves the measure metadata for the provided instanceId and measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Boolean for historical stats
   *
   * @param {number} [options.historicStatsDays] Format - int32. Number of
   * lookback days
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getMetadataForAMeasure(instanceId: string, measureName: string, options?: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getMetadataForAMeasure(instanceId: string, measureName: string, callback: ServiceCallback<any>): void;
  getMetadataForAMeasure(instanceId: string, measureName: string, options: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Updates measures metadata for the provided instanceId and
   * measureMetadata.
   * Existing measure is retrieved using measureName.
   *
   * Updates measures metadata for the provided instanceId and measureMetadata.
   * Existing measure is retrieved using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Update measure metadata
   *
   * @param {string} [options.body.name] Gets the unique name of the measure
   *
   * @param {string} [options.body.description] Gets the description of the
   * measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Gets or sets the
   * evaluation completion time.
   *
   * @param {string} [options.body.latestEvaluation.error] Gets or sets the error
   * (if any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Gets the output folder path for
   * the evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Gets the last
   * successful evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount] Gets
   * the number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Gets the last
   * validation evaluation date
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Gets the evaluation history
   * for the measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Gets the output history for the
   * measure. (not persisted in store)
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateAMeasureWithHttpOperationResponse(instanceId: string, measureName: string, options?: { body? : models.MeasureMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Updates measures metadata for the provided instanceId and
   * measureMetadata.
   * Existing measure is retrieved using measureName.
   *
   * Updates measures metadata for the provided instanceId and measureMetadata.
   * Existing measure is retrieved using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Update measure metadata
   *
   * @param {string} [options.body.name] Gets the unique name of the measure
   *
   * @param {string} [options.body.description] Gets the description of the
   * measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Gets or sets the
   * evaluation completion time.
   *
   * @param {string} [options.body.latestEvaluation.error] Gets or sets the error
   * (if any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Gets the output folder path for
   * the evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Gets the last
   * successful evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount] Gets
   * the number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Gets the last
   * validation evaluation date
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Gets the evaluation history
   * for the measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Gets the output history for the
   * measure. (not persisted in store)
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAMeasure(instanceId: string, measureName: string, options?: { body? : models.MeasureMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateAMeasure(instanceId: string, measureName: string, callback: ServiceCallback<any>): void;
  updateAMeasure(instanceId: string, measureName: string, options: { body? : models.MeasureMetadata, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Deletes the measure metadata for the provided instanceId using
   * measureName.
   *
   * Deletes the measure metadata for the provided instanceId using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteAMeasureWithHttpOperationResponse(instanceId: string, measureName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Deletes the measure metadata for the provided instanceId using
   * measureName.
   *
   * Deletes the measure metadata for the provided instanceId using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAMeasure(instanceId: string, measureName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteAMeasure(instanceId: string, measureName: string, callback: ServiceCallback<any>): void;
  deleteAMeasure(instanceId: string, measureName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Gets the KeyRing (collection of all alternate keys) for the given
   * instance by alternate key.
   *
   * Gets the KeyRing (collection of all alternate keys) for the given instance
   * by alternate key.
   *
   * @param {string} instanceId Format - uuid. Identifier for the instance
   *
   * @param {string} dataSourceName The name of the datasource that contains the
   * given entity.
   *
   * @param {string} entityName The name of the entity that contains the given
   * key.
   *
   * @param {string} key The value of the alternate key provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApiErrorResult>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getKeyRingWithHttpOperationResponse(instanceId: string, dataSourceName: string, entityName: string, key: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApiErrorResult>>;

  /**
   * @summary Gets the KeyRing (collection of all alternate keys) for the given
   * instance by alternate key.
   *
   * Gets the KeyRing (collection of all alternate keys) for the given instance
   * by alternate key.
   *
   * @param {string} instanceId Format - uuid. Identifier for the instance
   *
   * @param {string} dataSourceName The name of the datasource that contains the
   * given entity.
   *
   * @param {string} entityName The name of the entity that contains the given
   * key.
   *
   * @param {string} key The value of the alternate key provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApiErrorResult} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApiErrorResult} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApiErrorResult} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getKeyRing(instanceId: string, dataSourceName: string, entityName: string, key: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApiErrorResult>;
  getKeyRing(instanceId: string, dataSourceName: string, entityName: string, key: string, callback: ServiceCallback<models.ApiErrorResult>): void;
  getKeyRing(instanceId: string, dataSourceName: string, entityName: string, key: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApiErrorResult>): void;


  /**
   * @summary Gets the profile store state infoformation.
   *
   * Gets the profile store state infoformation.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getProfileStoreStateWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Gets the profile store state infoformation.
   *
   * Gets the profile store state infoformation.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getProfileStoreState(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getProfileStoreState(instanceId: string, callback: ServiceCallback<any>): void;
  getProfileStoreState(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Get all role definitions.
   *
   * Get all role definitions.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllRoleDefinitionsWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RoleDefinition[]>>;

  /**
   * @summary Get all role definitions.
   *
   * Get all role definitions.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRoleDefinitions(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RoleDefinition[]>;
  getAllRoleDefinitions(instanceId: string, callback: ServiceCallback<models.RoleDefinition[]>): void;
  getAllRoleDefinitions(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RoleDefinition[]>): void;


  /**
   * @summary Get role of current user.
   *
   * Get role of current user.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RoleAssignment>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getCurrentUserRoleWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RoleAssignment>>;

  /**
   * @summary Get role of current user.
   *
   * Get role of current user.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {RoleAssignment} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {RoleAssignment} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RoleAssignment} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getCurrentUserRole(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RoleAssignment>;
  getCurrentUserRole(instanceId: string, callback: ServiceCallback<models.RoleAssignment>): void;
  getCurrentUserRole(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RoleAssignment>): void;


  /**
   * @summary Adds or updates a role assignment for a principal.
   *
   * Adds or updates a role assignment for a principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The role assignment.
   *
   * @param {string} [options.body.principalId] Gets the Id of the principal.
   *
   * @param {string} [options.body.principalType] Possible values include:
   * 'user', 'group', 'app'
   *
   * @param {array} [options.body.roles] Gets the roles the principal belongs to.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateARoleAssignmentWithHttpOperationResponse(instanceId: string, principalId: string, options?: { body? : models.RoleAssignment, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RoleAssignment[]>>;

  /**
   * @summary Adds or updates a role assignment for a principal.
   *
   * Adds or updates a role assignment for a principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The role assignment.
   *
   * @param {string} [options.body.principalId] Gets the Id of the principal.
   *
   * @param {string} [options.body.principalType] Possible values include:
   * 'user', 'group', 'app'
   *
   * @param {array} [options.body.roles] Gets the roles the principal belongs to.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateARoleAssignment(instanceId: string, principalId: string, options?: { body? : models.RoleAssignment, customHeaders? : { [headerName: string]: string; } }): Promise<models.RoleAssignment[]>;
  updateARoleAssignment(instanceId: string, principalId: string, callback: ServiceCallback<models.RoleAssignment[]>): void;
  updateARoleAssignment(instanceId: string, principalId: string, options: { body? : models.RoleAssignment, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RoleAssignment[]>): void;


  /**
   * @summary Deletes a role assignment for the principal.
   *
   * Deletes a role assignment for the principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deletesARoleAssignmentWithHttpOperationResponse(instanceId: string, principalId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes a role assignment for the principal.
   *
   * Deletes a role assignment for the principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deletesARoleAssignment(instanceId: string, principalId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deletesARoleAssignment(instanceId: string, principalId: string, callback: ServiceCallback<void>): void;
  deletesARoleAssignment(instanceId: string, principalId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets all role assignments for the instance.
   *
   * Gets all role assignments for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllRoleAssignmentsWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RoleAssignment[]>>;

  /**
   * @summary Gets all role assignments for the instance.
   *
   * Gets all role assignments for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRoleAssignments(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RoleAssignment[]>;
  getAllRoleAssignments(instanceId: string, callback: ServiceCallback<models.RoleAssignment[]>): void;
  getAllRoleAssignments(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RoleAssignment[]>): void;


  /**
   * @summary Gets all relationship metadata for the provided instanceId.
   *
   * Gets all relationship metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllRelationshipsWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Gets all relationship metadata for the provided instanceId.
   *
   * Gets all relationship metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRelationships(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllRelationships(instanceId: string, callback: ServiceCallback<any>): void;
  getAllRelationships(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Creates new relationship metadata for the provided instanceId,
   * using input.
   *
   * Creates new relationship metadata for the provided instanceId, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createARelationshipWithHttpOperationResponse(instanceId: string, options?: { body? : models.RelationshipMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Creates new relationship metadata for the provided instanceId,
   * using input.
   *
   * Creates new relationship metadata for the provided instanceId, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createARelationship(instanceId: string, options?: { body? : models.RelationshipMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createARelationship(instanceId: string, callback: ServiceCallback<any>): void;
  createARelationship(instanceId: string, options: { body? : models.RelationshipMetadata, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Gets the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * Gets the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getARelationshipWithHttpOperationResponse(instanceId: string, relationshipName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Gets the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * Gets the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getARelationship(instanceId: string, relationshipName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getARelationship(instanceId: string, relationshipName: string, callback: ServiceCallback<any>): void;
  getARelationship(instanceId: string, relationshipName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Deletes the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * Deletes the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteARelationshipWithHttpOperationResponse(instanceId: string, relationshipName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Deletes the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * Deletes the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteARelationship(instanceId: string, relationshipName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteARelationship(instanceId: string, relationshipName: string, callback: ServiceCallback<any>): void;
  deleteARelationship(instanceId: string, relationshipName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Updates the relationship metadata for the provided instanceId and
   * relationshipName, using input.
   *
   * Updates the relationship metadata for the provided instanceId and
   * relationshipName, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateARelationshipWithHttpOperationResponse(instanceId: string, relationshipName: string, options?: { body? : models.RelationshipMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Updates the relationship metadata for the provided instanceId and
   * relationshipName, using input.
   *
   * Updates the relationship metadata for the provided instanceId and
   * relationshipName, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateARelationship(instanceId: string, relationshipName: string, options?: { body? : models.RelationshipMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateARelationship(instanceId: string, relationshipName: string, callback: ServiceCallback<any>): void;
  updateARelationship(instanceId: string, relationshipName: string, options: { body? : models.RelationshipMetadata, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Gets the search configuration for the instance.
   *
   * Gets the search configuration for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getSearchConfigurationWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Gets the search configuration for the instance.
   *
   * Gets the search configuration for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getSearchConfiguration(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getSearchConfiguration(instanceId: string, callback: ServiceCallback<any>): void;
  getSearchConfiguration(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Updates the search configuration for the instance.
   *
   * Updates the search configuration for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The search configuration for the instance.
   *
   * @param {array} [options.body.entityConfig] Gets search configurations for
   * entities
   *
   * @param {boolean} [options.body.isSystemGenerated] Gets a value indicating
   * whether the configuration was system generated
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateSearchConfigurationWithHttpOperationResponse(instanceId: string, options?: { body? : models.InstanceSearchConfiguration, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Updates the search configuration for the instance.
   *
   * Updates the search configuration for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The search configuration for the instance.
   *
   * @param {array} [options.body.entityConfig] Gets search configurations for
   * entities
   *
   * @param {boolean} [options.body.isSystemGenerated] Gets a value indicating
   * whether the configuration was system generated
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSearchConfiguration(instanceId: string, options?: { body? : models.InstanceSearchConfiguration, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateSearchConfiguration(instanceId: string, callback: ServiceCallback<any>): void;
  updateSearchConfiguration(instanceId: string, options: { body? : models.InstanceSearchConfiguration, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves a list of segment metadata for the provided instanceId.
   *
   * Retrieves a list of segment metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Optional parameter to
   * retrieve evaluation history of all the sgements in instanceId.
   *
   * @param {number} [options.historicStatsDays] Format - int32. Optional
   * parameter to get number of days evaluation history.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllSegmentsWithHttpOperationResponse(instanceId: string, options?: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves a list of segment metadata for the provided instanceId.
   *
   * Retrieves a list of segment metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Optional parameter to
   * retrieve evaluation history of all the sgements in instanceId.
   *
   * @param {number} [options.historicStatsDays] Format - int32. Optional
   * parameter to get number of days evaluation history.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllSegments(instanceId: string, options?: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllSegments(instanceId: string, callback: ServiceCallback<any>): void;
  getAllSegments(instanceId: string, options: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Create new segment metadata with segmentMetadata on instanceId.
   *
   * Create new segment metadata with segmentMetadata on instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be created
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Gets the last
   * validation evaluation date
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createASegmentWithHttpOperationResponse(instanceId: string, options?: { body? : models.SegmentMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Create new segment metadata with segmentMetadata on instanceId.
   *
   * Create new segment metadata with segmentMetadata on instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be created
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Gets the last
   * validation evaluation date
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createASegment(instanceId: string, options?: { body? : models.SegmentMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createASegment(instanceId: string, callback: ServiceCallback<any>): void;
  createASegment(instanceId: string, options: { body? : models.SegmentMetadata, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Activate segment on instanceId with segmentName.
   *
   * Activate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  activateSegmentWithHttpOperationResponse(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Activate segment on instanceId with segmentName.
   *
   * Activate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  activateSegment(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  activateSegment(instanceId: string, segmentName: string, callback: ServiceCallback<any>): void;
  activateSegment(instanceId: string, segmentName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Deactivate segment on instanceId with segmentName.
   *
   * Deactivate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deactivateSegmentWithHttpOperationResponse(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Deactivate segment on instanceId with segmentName.
   *
   * Deactivate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deactivateSegment(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deactivateSegment(instanceId: string, segmentName: string, callback: ServiceCallback<any>): void;
  deactivateSegment(instanceId: string, segmentName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Updates segment metadata for the provided instanceId and
   * segmentName with segmentMetadata.
   *
   * Updates segment metadata for the provided instanceId and segmentName with
   * segmentMetadata.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be updated
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Gets the last
   * validation evaluation date
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateASegmentWithHttpOperationResponse(instanceId: string, segmentName: string, options?: { body? : models.SegmentMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Updates segment metadata for the provided instanceId and
   * segmentName with segmentMetadata.
   *
   * Updates segment metadata for the provided instanceId and segmentName with
   * segmentMetadata.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be updated
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Gets the last
   * validation evaluation date
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateASegment(instanceId: string, segmentName: string, options?: { body? : models.SegmentMetadata, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateASegment(instanceId: string, segmentName: string, callback: ServiceCallback<any>): void;
  updateASegment(instanceId: string, segmentName: string, options: { body? : models.SegmentMetadata, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Deletes the segment metadata for the provided instanceId and
   * segmentName.
   *
   * Deletes the segment metadata for the provided instanceId and segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletionResponse>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteSegmentWithHttpOperationResponse(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeletionResponse>>;

  /**
   * @summary Deletes the segment metadata for the provided instanceId and
   * segmentName.
   *
   * Deletes the segment metadata for the provided instanceId and segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {DeletionResponse} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {DeletionResponse} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletionResponse} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSegment(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.DeletionResponse>;
  deleteSegment(instanceId: string, segmentName: string, callback: ServiceCallback<models.DeletionResponse>): void;
  deleteSegment(instanceId: string, segmentName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeletionResponse>): void;


  /**
   * @summary Retrieve information about a workflow job.
   *
   * Retrieve information about a workflow job.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAWorkflowJobInformationWithHttpOperationResponse(instanceId: string, workflowName: string, jobId: string, options?: { includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieve information about a workflow job.
   *
   * Retrieve information about a workflow job.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAWorkflowJobInformation(instanceId: string, workflowName: string, jobId: string, options?: { includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAWorkflowJobInformation(instanceId: string, workflowName: string, jobId: string, callback: ServiceCallback<any>): void;
  getAWorkflowJobInformation(instanceId: string, workflowName: string, jobId: string, options: { includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Cancel a job.
   *
   * Cancel a job.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  cancelAWorkflowJobWithHttpOperationResponse(instanceId: string, workflowName: string, jobId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Cancel a job.
   *
   * Cancel a job.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelAWorkflowJob(instanceId: string, workflowName: string, jobId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  cancelAWorkflowJob(instanceId: string, workflowName: string, jobId: string, callback: ServiceCallback<any>): void;
  cancelAWorkflowJob(instanceId: string, workflowName: string, jobId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves a list of recent job information.
   *
   * Retrieves a list of recent job information.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of job informations
   * to retrieve.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getListOfRecentWorkflowJobsWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { top? : number, includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves a list of recent job information.
   *
   * Retrieves a list of recent job information.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of job informations
   * to retrieve.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getListOfRecentWorkflowJobs(instanceId: string, workflowName: string, options?: { top? : number, includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getListOfRecentWorkflowJobs(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  getListOfRecentWorkflowJobs(instanceId: string, workflowName: string, options: { top? : number, includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Submits a workflow of OperationTypeoperationType for the instance
   * specified in instanceId.
   * Optionally takes a list of identifiers, only if operationType is not
   * OperationType.All and a flag
   * forceRunRequested indicating whether to force run.
   *
   * Submits a workflow of OperationTypeoperationType for the instance specified
   * in instanceId.
   * Optionally takes a list of identifiers, only if operationType is not
   * OperationType.All and a flag
   * forceRunRequested indicating whether to force run.
   *
   * @param {string} instanceId Format - uuid. The Customer Insights instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Job Creation Request.
   *
   * @param {string} [options.body.graphName]
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
   * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
   * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
   * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
   * 'roleAssignment', 'analysis', 'all'
   *
   * @param {string} [options.body.submissionKind] Possible values include:
   * 'onDemand', 'scheduled'
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {array} [options.body.identifiers]
   *
   * @param {boolean} [options.body.forceRunRequested]
   *
   * @param {string} [options.body.inputRefreshMode] Possible values include:
   * 'FailedOrModifiedRecursive', 'FailedRecursive', 'FailedOrModified', 'Failed'
   *
   * @param {string} [options.operationType] The workflow operation type.
   *
   * @param {array} [options.identifiers] A list of workflow identifiers.
   *
   * @param {boolean} [options.forceRunRequested] Whether to request a force run.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  submitAWorkflowJobWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { body? : models.OnDemandJobRequest, operationType? : string, identifiers? : string[], forceRunRequested? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Submits a workflow of OperationTypeoperationType for the instance
   * specified in instanceId.
   * Optionally takes a list of identifiers, only if operationType is not
   * OperationType.All and a flag
   * forceRunRequested indicating whether to force run.
   *
   * Submits a workflow of OperationTypeoperationType for the instance specified
   * in instanceId.
   * Optionally takes a list of identifiers, only if operationType is not
   * OperationType.All and a flag
   * forceRunRequested indicating whether to force run.
   *
   * @param {string} instanceId Format - uuid. The Customer Insights instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Job Creation Request.
   *
   * @param {string} [options.body.graphName]
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
   * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
   * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
   * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
   * 'roleAssignment', 'analysis', 'all'
   *
   * @param {string} [options.body.submissionKind] Possible values include:
   * 'onDemand', 'scheduled'
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {array} [options.body.identifiers]
   *
   * @param {boolean} [options.body.forceRunRequested]
   *
   * @param {string} [options.body.inputRefreshMode] Possible values include:
   * 'FailedOrModifiedRecursive', 'FailedRecursive', 'FailedOrModified', 'Failed'
   *
   * @param {string} [options.operationType] The workflow operation type.
   *
   * @param {array} [options.identifiers] A list of workflow identifiers.
   *
   * @param {boolean} [options.forceRunRequested] Whether to request a force run.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  submitAWorkflowJob(instanceId: string, workflowName: string, options?: { body? : models.OnDemandJobRequest, operationType? : string, identifiers? : string[], forceRunRequested? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  submitAWorkflowJob(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  submitAWorkflowJob(instanceId: string, workflowName: string, options: { body? : models.OnDemandJobRequest, operationType? : string, identifiers? : string[], forceRunRequested? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Retrieves a list of historic task information for a workflow.
   *
   * Retrieves a list of historic task information for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of task
   * informations to retrieve.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getListOfWorkflowTaskInformationHistoryWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Retrieves a list of historic task information for a workflow.
   *
   * Retrieves a list of historic task information for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of task
   * informations to retrieve.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getListOfWorkflowTaskInformationHistory(instanceId: string, workflowName: string, options?: { top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getListOfWorkflowTaskInformationHistory(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  getListOfWorkflowTaskInformationHistory(instanceId: string, workflowName: string, options: { top? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Gets the current status for a workflow.
   *
   * Gets the current status for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getWorkflowStatusWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Gets the current status for a workflow.
   *
   * Gets the current status for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowStatus(instanceId: string, workflowName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getWorkflowStatus(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  getWorkflowStatus(instanceId: string, workflowName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Gets a list of supported timezones for creating workflow schedules.
   *
   * Gets a list of supported timezones for creating workflow schedules.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getSupportedTimezonesWithHttpOperationResponse(workflowName: string, instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Gets a list of supported timezones for creating workflow schedules.
   *
   * Gets a list of supported timezones for creating workflow schedules.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getSupportedTimezones(workflowName: string, instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getSupportedTimezones(workflowName: string, instanceId: string, callback: ServiceCallback<any>): void;
  getSupportedTimezones(workflowName: string, instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Gets all workflow refresh schedules.
   *
   * Gets all workflow refresh schedules.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getWorkflowSchedulesWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Gets all workflow refresh schedules.
   *
   * Gets all workflow refresh schedules.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowSchedules(instanceId: string, workflowName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getWorkflowSchedules(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  getWorkflowSchedules(instanceId: string, workflowName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Create a workflow refresh schedule.
   *
   * Create a workflow refresh schedule.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] A schedule object to create.
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
   * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
   * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
   * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
   * 'roleAssignment', 'analysis', 'all'
   *
   * @param {string} [options.body.subType] Possible values include:
   * 'templatedMeasures', 'createAnalysisModel', 'linkAnalysisModel'
   *
   * @param {array} [options.body.identifiers] Gets the identifiers of the
   * schedule
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createWorkflowRefreshScheduleWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { body? : models.WorkflowRefreshSchedule, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Create a workflow refresh schedule.
   *
   * Create a workflow refresh schedule.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] A schedule object to create.
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
   * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
   * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
   * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
   * 'roleAssignment', 'analysis', 'all'
   *
   * @param {string} [options.body.subType] Possible values include:
   * 'templatedMeasures', 'createAnalysisModel', 'linkAnalysisModel'
   *
   * @param {array} [options.body.identifiers] Gets the identifiers of the
   * schedule
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createWorkflowRefreshSchedule(instanceId: string, workflowName: string, options?: { body? : models.WorkflowRefreshSchedule, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createWorkflowRefreshSchedule(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  createWorkflowRefreshSchedule(instanceId: string, workflowName: string, options: { body? : models.WorkflowRefreshSchedule, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Gets the entityProfile for the entity.
   *
   * Gets the entityProfile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityDataProfile>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAnEntityProfileWithHttpOperationResponse(instanceId: string, qualifiedEntityName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.EntityDataProfile>>;

  /**
   * @summary Gets the entityProfile for the entity.
   *
   * Gets the entityProfile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {EntityDataProfile} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {EntityDataProfile} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityDataProfile} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAnEntityProfile(instanceId: string, qualifiedEntityName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.EntityDataProfile>;
  getAnEntityProfile(instanceId: string, qualifiedEntityName: string, callback: ServiceCallback<models.EntityDataProfile>): void;
  getAnEntityProfile(instanceId: string, qualifiedEntityName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.EntityDataProfile>): void;
}

export { CustomerInsights, models as CustomerInsightsModels };
